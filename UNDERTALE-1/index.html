<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Undertale風戦闘システム</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --border-style: 4px solid #fff;
            --box-bg-color: #000;
            --font-family: 'Press Start', cursive;
            --font-color: #fff;
        }

        body {
            background-color: #000;
            color: var(--font-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            flex-direction: column;
            overflow: hidden; /* スクロールバーを非表示 */
        }

        #game-container {
            width: 640px;
            height: 480px;
            background-color: var(--box-bg-color);
            border: var(--border-style);
            display: grid;
            grid-template-rows: 1fr 1fr;
            grid-template-columns: 1fr;
            padding: 20px;
            transform: scale(0.9); /* スマホ表示用に少し縮小 */
        }
        
        @media (max-width: 640px) {
             #game-container {
                width: 100vw;
                height: auto;
                border: none;
                padding: 5px;
                transform: scale(1);
             }
        }


        #top-section {
            /* 敵やメッセージが表示されるエリア (今は空) */
        }
        
        #bottom-section {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            justify-items: center;
        }

        #player-info {
            /* プレイヤー情報 (HPなど) */
        }

        #battle-box-container {
            /* JSで描画するため、CSSの枠線は不要 */
            width: 250px;
            height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #battle-canvas {
            background-color: #000;
        }
        
        #options-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
            width: 640px;
        }
        
         @media (max-width: 640px) {
             #options-container {
                 width: 100vw;
                 gap: 10px;
                 padding: 0 10px;
             }
             .option-button {
                 font-size: 16px !important;
             }
         }


        .option-button {
            background: none;
            border: none;
            color: var(--font-color);
            font-family: var(--font-family);
            font-size: 22px;
            text-align: left;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .option-button:hover, .option-button.selected {
            color: #ff0; /* 黄色 */
        }

        .heart-icon {
            width: 24px;
            height: 24px;
            margin-right: 15px;
        }

        /* スティックUIのコンテナ */
        #joystick-container {
            position: fixed;
            bottom: 30px;
            right: 30px; /* 右下に配置 */
            width: 150px;
            height: 150px;
            opacity: 0.8; /* 見やすくするために少し濃くする */
            display: block; /* 常に表示 */
        }
        
    </style>
</head>
<body>

    <!-- ゲーム全体のコンテナ -->
    <div id="game-container">
        <!-- 上半分 (敵やメッセージ用) -->
        <div id="top-section">
             <!-- ここに敵キャラクターやメッセージボックスが入ります -->
        </div>

        <!-- 下半分 (戦闘フィールドとプレイヤー情報) -->
        <div id="bottom-section">
            <div id="player-info">
                <!-- ここにプレイヤー名やHPが入ります -->
            </div>
            <div id="battle-box-container">
                <canvas id="battle-canvas" width="250" height="250"></canvas>
            </div>
             <div>
                <!-- 右側の空スペース -->
            </div>
        </div>
    </div>
    
    <!-- 操作ボタン -->
    <div id="options-container">
        <button class="option-button selected" id="fight">
            <svg class="heart-icon" viewBox="0 0 10 10" fill="#ff0"><path d="M5 1 L1 5 L5 9 L9 5 Z"/></svg>
            * FIGHT
        </button>
        <button class="option-button" id="act">
             * ACT
        </button>
        <button class="option-button" id="item">
             * ITEM
        </button>
        <button class="option-button" id="mercy">
             * MERCY
        </button>
    </div>

    <!-- スティックUI用のコンテナ -->
    <div id="joystick-container"></div>
    
    <!-- スティックのライブラリを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        const canvas = document.getElementById('battle-canvas');
        const ctx = canvas.getContext('2d');

        // 戦闘フィールドの定義
        const battleBox = {
            width: 150,
            height: 150,
            x: (canvas.width - 150) / 2,  // canvasの中央に配置
            y: (canvas.height - 150) / 2, // canvasの中央に配置
        };

        // プレイヤー（ハート）の状態
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            width: 20, // 当たり判定の幅
            height: 20, // 当たり判定の高さ
            speed: 3,
            isInvincible: false, // 無敵状態フラグ
            invincibleTimer: 0 // 無敵時間タイマー
        };

        // 弾を管理する配列
        const bullets = [];

        // 追尾弾の確率管理用タイマー
        let framesSinceLastHoming = 0;

        // キー入力の状態を管理するオブジェクト
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // スティックの入力ベクトル
        let joystickVector = { x: 0, y: 0 };

        // ハートを描画する関数
        function drawPlayer() {
            if (player.isInvincible && Math.floor(player.invincibleTimer / 6) % 2 === 0) {
                return;
            }
            ctx.fillStyle = '#ff0000';
            ctx.font = "20px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText('❤️', player.x, player.y);
        }
        
        // プレイヤーの位置を更新する関数
        function updatePlayerPosition() {
            let moveX = 0;
            let moveY = 0;

            // スティック入力があれば優先
            if (joystickVector.x !== 0 || joystickVector.y !== 0) {
                moveX = joystickVector.x;
                moveY = joystickVector.y;
            } else { // なければキーボード入力をチェック
                if (keys.ArrowUp) moveY -= 1;
                if (keys.ArrowDown) moveY += 1;
                if (keys.ArrowLeft) moveX -= 1;
                if (keys.ArrowRight) moveX += 1;

                // キーボードの斜め移動速度を正規化
                const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
                if (magnitude > 1) {
                    moveX /= magnitude;
                    moveY /= magnitude;
                }
            }
            
            // プレイヤーを動かす
            player.x += moveX * player.speed;
            player.y += moveY * player.speed;


            // 壁の衝突判定をbattleBox基準に変更
            if (player.x - player.width / 2 < battleBox.x) player.x = battleBox.x + player.width / 2;
            if (player.x + player.width / 2 > battleBox.x + battleBox.width) player.x = battleBox.x + battleBox.width - player.width / 2;
            if (player.y - player.height / 2 < battleBox.y) player.y = battleBox.y + player.height / 2;
            if (player.y + player.height / 2 > battleBox.y + battleBox.height) player.y = battleBox.y + battleBox.height - player.height / 2;
            
            if (player.isInvincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.isInvincible = false;
                }
            }
        }
        
        // 新しい弾を生成する関数
        function createBullet() {
            let startX, startY;
            const side = Math.floor(Math.random() * 4); 
            
            switch(side) {
                case 0: startX = Math.random() * canvas.width; startY = -10; break;
                case 1: startX = canvas.width + 10; startY = Math.random() * canvas.height; break;
                case 2: startX = Math.random() * canvas.width; startY = canvas.height + 10; break;
                case 3: startX = -10; startY = Math.random() * canvas.height; break;
            }
            
            let isHoming = false;
            const secondsSince = framesSinceLastHoming / 60;

            // 5秒経過していたら強制的に追尾弾にする
            if (secondsSince >= 5) {
                isHoming = true;
            } else {
                // 時間経過で確率を計算 (0.2 + 0.16 * 秒数)
                const homingChance = 0.20 + 0.16 * secondsSince;
                if (Math.random() < homingChance) {
                    isHoming = true;
                }
            }

            if (isHoming) {
                framesSinceLastHoming = 0; // タイマーをリセット
            }

            const angle = Math.atan2(player.y - startY, player.x - startX);
            const speed = isHoming ? 1.5 : 2; // 追尾弾は少し遅くする

            const bullet = {
                x: startX, 
                y: startY, 
                radius: 5, // 半径
                speedX: Math.cos(angle) * speed, 
                speedY: Math.sin(angle) * speed,
                color: isHoming ? '#ff3333' : '#fff', // 追尾弾は赤色
                isHoming: isHoming,
                lifetime: isHoming ? 600 : null, // 追尾弾の寿命(10秒 * 60fps)
                originalSpeed: speed // 追尾弾の速度維持用
            };
            bullets.push(bullet);
        }

        // 弾を描画する関数
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save(); // 現在の描画状態を保存
                if (bullet.isHoming && bullet.lifetime !== null && bullet.lifetime < 120) {
                    // 残り2秒でフェードアウト開始
                    ctx.globalAlpha = Math.max(0, bullet.lifetime / 120);
                }
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); // 描画状態を元に戻す
            });
        }

        // 弾の位置を更新する関数
        function updateBulletsPosition() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                if (bullet.isHoming) {
                    const turnRate = 0.0225; // 加速度を0.75倍に変更
                    const targetAngle = Math.atan2(player.y - bullet.y, player.x - bullet.x);
                    const currentAngle = Math.atan2(bullet.speedY, bullet.speedX);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    const turnAmount = Math.max(-turnRate, Math.min(turnRate, angleDiff));
                    const newAngle = currentAngle + turnAmount;
                    bullet.speedX = Math.cos(newAngle) * bullet.originalSpeed;
                    bullet.speedY = Math.sin(newAngle) * bullet.originalSpeed;
                    
                    if (bullet.lifetime !== null) {
                        bullet.lifetime--;
                        if (bullet.lifetime <= 0) {
                            bullets.splice(i, 1);
                            continue;
                        }
                    }
                }

                bullet.x += bullet.speedX;
                bullet.y += bullet.speedY;

                const margin = 10;
                if (bullet.x < -margin || bullet.x > canvas.width + margin || bullet.y < -margin || bullet.y > canvas.height + margin) {
                    bullets.splice(i, 1);
                    continue; 
                }
            }
        }
        
        // 当たり判定をチェックする関数
        function checkCollisions() {
            if (player.isInvincible) return;

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (
                    player.x - player.width / 2 < bullet.x + bullet.radius &&
                    player.x + player.width / 2 > bullet.x - bullet.radius &&
                    player.y - player.height / 2 < bullet.y + bullet.radius &&
                    player.y + player.height / 2 > bullet.y - bullet.radius
                ) {
                    bullets.splice(i, 1);
                    player.isInvincible = true;
                    player.invincibleTimer = 30; // 無敵時間を0.5秒に変更 (30フレーム)
                    console.log("HIT!");
                    break;
                }
            }
        }

        // 戦闘フィールドの枠線を描画する関数
        function drawBattleBox() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(battleBox.x, battleBox.y, battleBox.width, battleBox.height);
        }

        // メインのゲームループ
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            framesSinceLastHoming++; // 追尾弾タイマーを更新

            drawBattleBox();
            updatePlayerPosition();
            updateBulletsPosition();
            checkCollisions();
            drawBullets();
            drawPlayer();
            requestAnimationFrame(gameLoop);
        }
        
        // キーボードイベント
        window.addEventListener('keydown', (e) => { if (e.key in keys) keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { if (e.key in keys) keys[e.key] = false; });
        
        // スティックUIの初期化
        try {
            const joystickManager = nipplejs.create({
                zone: document.getElementById('joystick-container'),
                mode: 'static',
                position: { right: '75px', bottom: '105px' },
                color: 'white',
                size: 120
            });

            joystickManager.on('move', (evt, data) => {
                const angle = data.angle.radian;
                const force = Math.min(data.force, 1.0);
                joystickVector.x = Math.cos(angle) * force;
                joystickVector.y = -Math.sin(angle) * force;
            });

            joystickManager.on('end', () => {
                joystickVector.x = 0;
                joystickVector.y = 0;
            });
        } catch (e) {
            console.log("Could not initialize joystick.");
        }

        // 700ミリ秒ごとに新しい弾を生成
        setInterval(createBullet, 700);
        
        // ゲームループを開始
        gameLoop();

    </script>
</body>
</html>

