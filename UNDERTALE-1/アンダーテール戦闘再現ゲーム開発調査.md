

# **TypeScriptとPhaserで実現するUndertale風戦闘システム：HTML5ゲーム開発のための技術調査レポート**

## **第1章: 基盤技術の選定とプロジェクトアーキテクチャ**

Undertaleの戦闘システムを模倣したHTML5ゲームをTypeScriptで開発するにあたり、プロジェクトの成功は初期の技術選定と堅牢なアーキテクチャ設計に大きく依存します。このセクションでは、最適なゲームエンジンの選定理由を詳述し、専門的な開発環境を構築するための具体的な手順を提示します。

### **1.1. エンジン選定：比較分析**

このプロジェクトの核心は、複雑なゲームプレイメカニクスの再現にあり、レンダリングライブラリよりも多機能なゲームフレームワークが適しています。ここでは、主要な選択肢であるPhaser 3とPixiJSを比較し、Phaser 3を推奨する技術的根拠を明確にします。

Phaserは完全な2Dゲームフレームワークであり、PixiJSは高性能な2Dレンダリングライブラリです 1。Phaserは歴史的にPixiJSをレンダリングに使用していましたが、現在は独自のエンジンを開発しています 2。この根本的な違いが、開発プロセス全体に大きな影響を与えます。

Phaserには、物理演算（Arcade Physics、Matter.js）、音声管理、入力ハンドリング、アニメーション、パーティクルシステムといった、ゲーム開発に不可欠な機能が標準で組み込まれています 1。一方、PixiJSはこれらの機能を持たず、開発者は自身で実装するか、音声処理にHowler.jsのような外部ライブラリを統合する必要があります 1。

以下の表は、本プロジェクトの要件に照らして両者を比較したものです。

**表1: Undertale風プロジェクトにおけるPhaser 3とPixiJSの比較分析**

| 機能・特性 | Phaser 3 | PixiJS | 推奨と論拠 |
| :---- | :---- | :---- | :---- |
| **基本理念** | ゲームフレームワーク | レンダリングライブラリ | **Phaser 3を推奨。** ゲーム全体の構造を提供するため、開発者はゲームプレイロジックに集中できる 1。 |
| **物理エンジン** | Arcade Physicsを内蔵 | 外部ライブラリ/カスタム実装が必要 | **Phaser 3を推奨。** 弾幕の当たり判定や特殊な移動（青ソウルなど）に最適な軽量物理エンジンが標準で利用可能 1。 |
| **弾幕性能** | Groupクラスによるオブジェクトプーリングで高性能を実現 | 純粋なスプライト描画性能は高い可能性があるが、最適化は手動 | **Phaser 3を推奨。** 標準機能で弾幕ゲームのパフォーマンス要件を十分に満たせる 5。 |
| **UIと状態管理** | rexUIやrexStateManagerなど強力なプラグインエコシステムが存在 | カスタム実装または外部ライブラリの統合が必要 | **Phaser 3を推奨。** ターン制の戦闘フローや複雑なUIを効率的に実装できる 7。 |
| **TypeScript対応** | 公式テンプレートで完全対応 | 対応しているが、セットアップは手動 | **Phaser 3を推奨。** 型安全な開発をスムーズに開始できる 9。 |
| **開発速度** | 高速（必要な機能が揃っている） | 低速（基盤システムの構築が必要） | **Phaser 3を推奨。** ゲームプレイのプロトタイピングを迅速に進められる 2。 |

この分析から導き出される結論は、プロジェクトの「複雑性の予算」をどこに配分するべきかという戦略的な問題に行き着きます。このプロジェクトの核心的な複雑性は、低レベルなレンダリング処理ではなく、状態遷移、弾幕パターン、ACTコマンドの分岐といった、入り組んだ**ゲームプレイロジック**にあります。

PixiJSを選択した場合、開発者はその「予算」の大部分を、物理エンジン、ゲームループ管理、入力システム、音声マネージャーといった、すでに解決済みの問題を再実装または統合するために費やすことになります 1。これは、プロジェクト固有の、そして最も魅力的な課題に取り組むためのリソースを浪費することを意味します。

対照的に、Phaserはこれらのシステムを標準で提供します。これにより、開発者は自身の「複雑性の予算」のすべてを、Undertaleの戦闘が持つ独特のメカニクスを再現するという本質的な作業に投下できます。したがって、プロジェクトの持つ高いゲームプレイの複雑性を考慮すると、Phaser 3の採用は戦略的に優れた選択となります。

### **1.2. 環境構築とプロジェクトの雛形作成**

最適なツールを選んだ後は、効率的でスケーラブルな開発環境を構築します。Phaserは公式のコマンドラインインターフェース（CLI）を提供しており、これを利用することでベストプラクティスに沿ったプロジェクトの雛形を迅速に作成できます 4。

以下に、具体的な手順を示します。

1. **前提条件**: Node.jsと任意のコードエディタ（例: Visual Studio Code）がインストールされていること。  
2. **プロジェクトの初期化**: ターミナルを開き、以下のコマンドを実行します。  
   Bash  
   npm create @phaserjs/game@latest

   10  
3. **対話式インストーラ**: インストーラが起動したら、指示に従って設定を選択します。本プロジェクトでは、**TypeScript**テンプレートと、Viteのようなモダンなバンドラーを選択することが推奨されます。  
4. **プロジェクト構造の理解**: コマンドが完了すると、index.html、ソースコードを格納するsrc/ディレクトリ、エントリーポイントとなるmain.ts、そしてデフォルトのSceneファイルが生成されます。この構造は、クリーンで管理しやすい開発の基盤となります 9。  
5. **開発サーバーの起動**: 以下のコマンドを実行し、プロジェクトの依存関係をインストールしてローカル開発サーバーを起動します。  
   Bash  
   npm install  
   npm run dev

これにより、ブラウザで即座に動作確認が可能な開発環境が整います。

## **第2章: Undertale戦闘システムの構造分解**

技術基盤を固めた次に、再現対象であるUndertaleの戦闘システムを、プログラム可能な構成要素へと分解します。この分析の中心的な設計思想として、戦闘全体の流れを管理する「有限ステートマシン（Finite State Machine, FSM）」という概念を導入します。

### **2.1. 有限ステートマシン（FSM）としての戦闘フロー**

Undertaleの戦闘は、単一の連続した処理ではなく、明確に定義された複数の「フェーズ（状態）」が遷移していくシーケンスです。この構造を管理する上で、FSMは極めて有効な設計パターンです。FSMを用いることで、状態遷移のロジックが明確になり、複雑な処理の流れを整理し、バグの発生を防ぐことができます。

戦闘の基本的なフローは、プレイヤーのターン、敵のセリフ、敵の攻撃、そしてターンの解決といったフェーズに分解できます 11。これを基に、以下のようなFSMの状態を定義します。

* BATTLE\_START: 戦闘開始時の演出（画面の切り替わり、モンスターの出現など）を処理する。  
* PLAYER\_TURN: プレイヤーがコマンド（FIGHT, ACTなど）を選択できる状態。プレイヤーの入力を待機する。  
* ENEMY\_DIALOGUE: 敵のターン開始時のセリフを表示する。  
* ENEMY\_ATTACK: 「弾幕フェーズ」。プレイヤーのソウル（ハート）がアクティブになり、敵の攻撃を回避する。  
* TURN\_END: ダメージ計算や戦闘終了条件（HPが0になる、見逃されるなど）を判定し、PLAYER\_TURNまたはBATTLE\_ENDへ遷移する。  
* BATTLE\_END: 勝利、敗北、見逃しなどの演出を処理し、戦闘を終了する。

このFSM構造は、戦闘システムの挙動を正確にモデル化するための重要な洞察を提供します。Undertaleの戦闘は、実際には**入れ子構造（ネスト）のステートマシン**として設計されています。

主要なFSMがプレイヤーと敵のターンという高レベルなフローを管理する一方で、個々の状態の内部には、さらに細かいサブステートが存在します。例えば、PLAYER\_TURN状態の中には、「コマンド選択中」「FIGHTミニゲーム実行中」「アイテム選択中」といった、互いに排他的なサブステートがあります。同様に、ENEMY\_ATTACK状態では、プレイヤーのソウルが「赤ソウル（自由移動）」「青ソウル（重力あり）」「黄ソウル（シューティング）」といった異なる制御状態に変化します 12。

この階層的な構造を認識することは、実装の質を大きく左右します。単純なフラットなFSMではこの複雑さを表現しきれず、コードが煩雑になる可能性があります。したがって、アーキテクチャは、戦闘全体の流れを管理する主要なステートマシンと、プレイヤーのアクションやソウルの物理法則を管理する個別のコントローラー（またはサブステートマシン）を持つ階層構造として設計する必要があります。

### **2.2. プレイヤーフェーズの分析：コマンドメニュー**

プレイヤーが行動を選択するPLAYER\_TURNフェーズは、4つの主要なコマンドで構成されています。

* **FIGHT**: タイミングベースのミニゲームです。動くバーを中央で止めるほど高いダメージを与えられますが、このシステムは単なるダメージ計算以上の意味を持ちます。それはプレイヤーの「危害を加える意図」を表現するものであり、武器によってバーの数や速度が変化します 13。  
* **ACT**: 敵や戦闘の状況に応じて内容が変化する、文脈依存のコマンドです。非暴力ルートの核心であり、複雑な分岐ロジックを必要とします 13。  
* **ITEM**: 消費アイテムを使用するための、標準的なRPGのインベントリメニューです 13。  
* **MERCY**: 特定の条件（特定のACTを実行した後など）を満たした敵をSPARE（見逃す）、または戦闘からFLEE（逃げる）ためのコマンドです 12。

### **2.3. 防御フェーズの分析：弾幕地獄**

敵の攻撃ターンは、弾幕シューティングゲームの形式を取ります。

* **ソウル（プレイヤーのアバター）**: プレイヤーは小さなハートで表現され、矩形のボックス内で敵の弾を避けなければなりません 14。  
* **ソウルのモード（色）**: 特定のボス戦ではソウルの色が変化し、移動方法が根本的に変わります 12。  
  * **赤**: 標準的な2D自由移動。  
  * **青**: 重力とジャンプを伴うプラットフォーマー物理。  
  * **緑**: 移動不可。盾で弾を防ぐ。  
  * **紫**: 水平な3本の線上のみを移動可能。  
  * **黄**: 上下反転し、弾を発射できる。  
* **弾の種類（色）**: 敵の攻撃弾の色によって、回避ルールが変化します 12。  
  * **白**: 通常の弾。接触するとダメージを受ける。  
  * **青**: プレイヤーが静止していればダメージを受けない。  
  * **オレンジ**: プレイヤーが動いていればダメージを受けない。  
  * **緑**: 接触して「回収」する必要がある弾。平和的な解決に必要 16。

## **第3章: Phaser 3によるコア実装**

このセクションでは、前章で分解した設計を、Phaser 3とTypeScriptを用いた具体的なコードに落とし込みます。プロジェクトで最も実践的かつコード中心の部分となります。

### **3.1. 戦闘シーンのアーキテクチャ設計**

まず、戦闘シーン全体の骨格となるBattleScene.tsを設計します。このクラスはPhaser.Sceneを継承し、戦闘に関するすべてのオブジェクトとロジックを管理します。

* preload(): 戦闘に必要なすべてのアセット（スプライトシート、音声ファイル、フォントなど）を事前に読み込みます 1。  
* create(): ゲームオブジェクト、UI要素、ステートマシン、物理グループ、入力ハンドラなど、シーンの初期化処理をすべてここで行います 1。  
* update(time, delta): ゲームのメインループです。このメソッド自体に複雑なロジックを記述するのではなく、FSMの現在アクティブな状態に処理を委譲する役割を担います 1。

### **3.2. 戦闘ステートマシンの実装**

戦闘フローを管理するために、Phaser 3用の強力なサードパーティ製プラグインであるrexStateManagerPluginを利用します。このプラグインは、イベント駆動型のクリーンなFSM実装を提供し、本プロジェクトのアーキテクチャ要件に完全に合致しています 7。

**実装手順:**

1. **プラグインの導入**: BattleSceneにプラグインをインストールし、インポートします。  
2. **ステートマシンの定義**: StateManagerインスタンスを生成し、第2章で定義した状態（PLAYER\_TURN、ENEMY\_ATTACKなど）をTypeScriptで定義します。  
3. **状態遷移ロジックの実装**: 各状態定義内でenterとexitコールバックを使用し、ゲームロジックを制御します。例えば、PLAYER\_TURNのenterでコマンドUIを表示し、exitで非表示にする、といった処理を記述します。  
4. **遷移のトリガー**: プレイヤーのアクション確定や敵の攻撃終了といったゲーム内イベントに応じて、states.next()やstates.goto('STATE\_NAME')を呼び出し、状態を遷移させます。

### **3.3. ユーザーインターフェースの構築**

複雑でインタラクティブなUIをゼロから構築するのは時間がかかります。ここでは、Phaser 3用のUIプラグインスイートであるrexUIを活用し、効率的に高品質なUIを実装します 8。

#### **3.3.1. コマンドメニュー**

Phaser 3にはPhaser 2のような標準のButtonクラスが存在しないため、プラグインやカスタムクラスの利用が推奨されます 19。rexUIは強力なButtonsクラスを提供しており、これを利用します 18。

**実装手順:**

* rexUI.Buttonsコンテナを作成し、FIGHT, ACT, ITEM, MERCYの4つのボタンを管理します。  
* 'button.click'イベントをリッスンし、クリックされたボタンに応じてFSMの状態遷移をトリガーするコールバックを実装します。

#### **3.3.2. ダイアログシステム**

Undertaleのテキスト表示の核となるのが、タイプライターエフェクトです。rexUI.TextBoxと、それに組み込まれたTypingビヘイビアは、まさにこの機能を実現するために設計されています 8。

**実装手順:**

1. 背景画像（9-sliceスプライトが望ましい）とテキストオブジェクトを持つrexUI.TextBoxを生成します。  
2. textBox.start(text, speed)を呼び出して、タイプライターエフェクトを開始します。  
3. **重要な点として、'typechar'イベントをリッスンします。** このイベントは一文字が表示されるたびに発火するため、このタイミングで文字表示音を再生することで、原作の感覚を忠実に再現できます。  
4. 'pageend'や'complete'イベントを利用して、複数ページにわたるセリフを管理し、プレイヤーの入力を待ってから次のページへ進む処理を実装します。

### **3.4. 弾幕エンジンの設計**

戦闘のもう一つの柱である弾幕パートを、パフォーマンスと拡張性を両立させて構築します。

#### **3.4.1. オブジェクトプーリングによる高性能な弾管理**

毎秒数百もの弾スプライトを生成・破棄する処理は、メモリ確保とガベージコレクションにより深刻なパフォーマンス低下を引き起こします。この問題に対する標準的な解決策がオブジェクトプーリングです 20。PhaserのPhaser.GameObjects.Groupは、オブジェクトプールとして機能するように設計されています 6。

**実装手順:**

1. 弾を管理するためのPhaser.Physics.Arcade.Groupを作成します。  
2. 弾を発射する際は、group.get()メソッドを使用してプールから非アクティブな弾を取得します。利用可能な弾がない場合、グループは自動的に新しい弾を生成するように設定できます 21。  
3. 取得した弾は、位置と速度を設定され、アクティブ化・可視化されます。  
4. 弾が画面外に出るか何かに衝突した場合、オブジェクトを破棄する代わりにsetActive(false)とsetVisible(false)を呼び出して非アクティブ化し、プールに返却します。これにより、オブジェクトは再利用可能な状態になります 21。

#### **3.4.2. プレイヤーのソウルコントローラー**

ソウルの多様な移動モードを管理するため、ステートパターンを用いたTypeScriptクラスを設計します。

**実装手順:**

1. Phaser.Physics.Arcade.Spriteを継承したSoulクラスを作成します。  
2. setState('COLOR')のようなメソッドを実装し、内部の状態（RED, BLUEなど）を切り替えられるようにします。  
3. Soulクラスのupdateメソッド内で、現在の状態に基づいたswitch文を使用し、異なる入力処理と物理ロジックを適用します。例えば、'BLUE'状態では重力を適用しジャンプ入力を検知し、'RED'状態では自由移動を許可します。これは、第2章で述べた入れ子構造のステートマシンを具体的に実装するものです。

#### **3.4.3. 攻撃パターンのスクリプト化**

敵の多彩な弾幕攻撃を柔軟かつ拡張可能に実装するため、データ駆動型のアプローチを採用します。弾幕パターンは、角度、速度、重力などを操作することで生成できます 22。

**アーキテクチャ:**

* 個々の攻撃パターンをカプセル化するAttackPatternベースクラスをTypeScriptで設計します。各敵の攻撃は、このクラスを継承した具体的なパターンスクリプトとして実装されます。  
* この設計により、攻撃ロジック（**何をするか**）と、それを使用する敵（**誰がするか**）が分離されます。敵オブジェクトは、使用するAttackPatternインスタンスのリストを持つだけで済みます。  
* 新しい攻撃パターンを追加する際は、AttackPatternを継承した新しいクラスを作成するだけでよく、既存の敵や戦闘のコアロジックを修正する必要がありません。これは、非常にスケーラブルで保守性の高い設計です。

**実装例:**

* **リング状攻撃**: 0度から360度までループし、各角度でscene.physics.velocityFromAngle()を使用して弾を発射する。  
* **渦巻き状攻撃**: リング状攻撃と同様だが、フレームごとに半径を広げるか、角度を少しずつずらして弾を発射する。  
* **波状攻撃**: 一直線に弾を発射しつつ、それらのY座標またはY軸方向の速度にサイン波を適用する。

## **第4章: アセットパイプラインと最終的な仕上げ**

ゲームの独特な雰囲気と感触を実現するためには、コード以外のビジュアルやオーディオアセットが不可欠です。このセクションでは、それらのアセットを作成または調達し、ゲームに統合する方法について解説します。

### **4.1. ビジュアル：アートスタイルとタイポグラフィ**

#### **4.1.1. ピクセルアート**

Undertaleのビジュアルは、シンプルながらも表現力豊かなピクセルアートによって特徴づけられています。

* **推奨ツール**: Asepriteは、ピクセルアートとアニメーション制作における業界標準ツールです 23。  
* **Phaserとの連携**: PhaserはAsepriteからエクスポートされたスプライトシートやアニメーションデータを直接インポートする機能をサポートしており、アートからゲームへのワークフローを効率化します 10。  
* **学習リソース**: キャラクターのスプライト作成やアニメーションに焦点を当てた、Asepriteの初心者向けチュートリアルが多数存在します 23。

#### **4.1.2. タイポグラフィ**

8ビットのビットマップフォントは、Undertaleの美学を構成する重要な要素です。

* **推奨フォント**: 「Press Start 2P」は、原作の雰囲気に非常に近いGoogle Fontであり、商用利用も可能です 26。「Pixelify Sans」など、他の選択肢も存在します 27。  
* **実装**: Phaser 3でビットマップフォントを読み込み、UIテキストの描画に使用する方法は、公式ドキュメントやコミュニティで解説されています。

### **4.2. オーディオ：サウンドデザインと統合**

レトロなサウンドエフェクトは、ゲームの没入感を高める上で極めて重要です。

#### **4.2.1. サウンドエフェクトの生成**

* **推奨ツール**: Bfxr（およびその前身であるSfxr）は、爆発音、レーザー音、コイン取得音といった8ビット風のサウンドエフェクトを簡単に生成できる無料ツールです 30。  
* **使用方法**: Bfxrのインターフェースは直感的です。「Hit/Hurt」のようなプリセットボタンや、「Randomize」「Mutate」機能を使うことで、専門知識がなくても短時間でカスタムサウンドのライブラリを作成できます。

#### **4.2.2. サウンドエフェクトの調達**

* **推奨リソース**: より複雑な音や環境音が必要な場合、Freesound.orgが役立ちます。これは、クリエイティブ・コモンズ・ライセンスで提供される膨大な音声ファイルの共同リポジトリです 33。  
* **ライセンスの確認**: Freesound.orgから素材を利用する際は、各ファイルのライセンス（CC0, CC BYなど）を必ず確認し、プロジェクトでの利用（特に配布を伴う場合）が許可されているかを確認することが不可欠です 34。

#### **4.2.3. ゲームへの統合**

* **実装**: Phaserに内蔵された音声マネージャーを使用します。preload()メソッドで音声ファイルを読み込み、this.sound.play('sound\_key')のようなコードで、弾のヒットやボタンのクリックといったゲーム内イベントに応じて音声を再生します。

## **結論と今後の開発パス**

本レポートでは、TypeScriptとPhaser 3を用いてUndertaleの戦闘システムをHTML5ゲームとして再現するための包括的な技術調査と実装計画を提示しました。

主要なアーキテクチャ上の推奨事項は以下の通りです。

1. **技術基盤としてPhaser 3を採用する**: 物理演算、音声、入力処理などの機能が統合されており、開発者は複雑なゲームプレイロジックの実装に集中できます。  
2. **戦闘フローを階層型FSMで構造化する**: rexStateManagerPluginを利用して、ターン制の主要な流れと、ソウルの移動モードのような内部的な状態をクリーンに管理します。  
3. **UI実装にrexUIプラグインを活用する**: タイプライター効果を持つテキストボックスやインタラクティブなボタンなど、高品質なUIを効率的に構築します。  
4. **弾幕のパフォーマンスをオブジェクトプーリングで確保する**: PhaserのGroupクラスを活用して、大量の弾を効率的に管理し、スムーズなフレームレートを維持します。

このプロトタイプを基盤として、さらにプロジェクトを拡張するための開発パスとして、以下のような方向性が考えられます。

* **データ駆動型モンスターシステムの構築**: モンスターのステータス、セリフ、攻撃パターンなどをJSONファイルで定義し、ゲームから動的に読み込むシステムを構築する。  
* **ACTシステムの拡張**: より複雑で複数ステップにわたるインタラクションを持つACTコマンドのロジックツリーを設計する。  
* **ITEMインベントリシステムの実装**: アイテムの所持、使用、効果を管理するシステムを構築する。  
* **ユニークなボス戦の設計**: 新しいソウルモードや、スクリプト化された特殊な攻撃パターンを持つ、原作のような記憶に残るボス戦をデザインする。

#### **引用文献**

1. Phaser vs PixiJS for making 2D games \- DEV Community, 10月 9, 2025にアクセス、 [https://dev.to/ritza/phaser-vs-pixijs-for-making-2d-games-2j8c](https://dev.to/ritza/phaser-vs-pixijs-for-making-2d-games-2j8c)  
2. Decide Pixi.js or Phaser \[closed\] \- Stack Overflow, 10月 9, 2025にアクセス、 [https://stackoverflow.com/questions/38509629/decide-pixi-js-or-phaser](https://stackoverflow.com/questions/38509629/decide-pixi-js-or-phaser)  
3. Phaser.js Development (Scripts, Animation, Physics, Render) \- Game Design, 10月 9, 2025にアクセス、 [https://www.gamedesigning.org/learn/phaser-js/](https://www.gamedesigning.org/learn/phaser-js/)  
4. Is someone use js in gamdev? Pixi or phaser or anything else? : r/gamedev \- Reddit, 10月 9, 2025にアクセス、 [https://www.reddit.com/r/gamedev/comments/1imcnyn/is\_someone\_use\_js\_in\_gamdev\_pixi\_or\_phaser\_or/](https://www.reddit.com/r/gamedev/comments/1imcnyn/is_someone_use_js_in_gamdev_pixi_or_phaser_or/)  
5. Shirajuki/js-game-rendering-benchmark: Performance comparison of Javascript rendering/game engines: Three.js, Pixi.js, Phaser, Babylon.js, Two.js, Hilo, melonJS, Kaboom, Kaplay, Kontra, Excalibur, Litecanvas, LittleJS, Canvas API and DOM. \- GitHub, 10月 9, 2025にアクセス、 [https://github.com/Shirajuki/js-game-rendering-benchmark](https://github.com/Shirajuki/js-game-rendering-benchmark)  
6. Game Optimization with Basic Object Pools in Phaser 3 @ Playful ..., 10月 9, 2025にアクセス、 [https://blog.ourcade.co/posts/2020/phaser-3-optimization-object-pool-basic/](https://blog.ourcade.co/posts/2020/phaser-3-optimization-object-pool-basic/)  
7. State manager \- Notes of Phaser 3 \- GitHub Pages, 10月 9, 2025にアクセス、 [https://rexrainbow.github.io/phaser3-rex-notes/docs/site/statemanager/](https://rexrainbow.github.io/phaser3-rex-notes/docs/site/statemanager/)  
8. Text box \- Notes of Phaser 3 \- GitHub Pages, 10月 9, 2025にアクセス、 [https://rexrainbow.github.io/phaser3-rex-notes/docs/site/ui-textbox/](https://rexrainbow.github.io/phaser3-rex-notes/docs/site/ui-textbox/)  
9. Using Phaser with TypeScript, 10月 9, 2025にアクセス、 [https://phaser.io/tutorials/how-to-use-phaser-with-typescript](https://phaser.io/tutorials/how-to-use-phaser-with-typescript)  
10. Phaser \- A fast, fun and free open source HTML5 game framework, 10月 9, 2025にアクセス、 [https://phaser.io/](https://phaser.io/)  
11. How to make a battle system like in Undertale? \- Reddit, 10月 9, 2025にアクセス、 [https://www.reddit.com/r/Undertale/comments/1eijln2/how\_to\_make\_a\_battle\_system\_like\_in\_undertale/](https://www.reddit.com/r/Undertale/comments/1eijln2/how_to_make_a_battle_system_like_in_undertale/)  
12. 【アンダーテール】バトルシステム解説【UNDERTALE】 | AppMedia, 10月 9, 2025にアクセス、 [https://appmedia.jp/undertale/76102769](https://appmedia.jp/undertale/76102769)  
13. The FIGHT Interface :: Undertale General Discussions, 10月 9, 2025にアクセス、 [https://steamcommunity.com/app/391540/discussions/0/458606248632863477/](https://steamcommunity.com/app/391540/discussions/0/458606248632863477/)  
14. Undertale \- Wikipedia, 10月 9, 2025にアクセス、 [https://en.wikipedia.org/wiki/Undertale](https://en.wikipedia.org/wiki/Undertale)  
15. Undertale: Combat Where Nobody Has To Die \- Parry Everything, 10月 9, 2025にアクセス、 [https://parryeverything.com/2021/09/24/undertale-combat-where-nobody-has-to-die/](https://parryeverything.com/2021/09/24/undertale-combat-where-nobody-has-to-die/)  
16. DELTARUNE's Combat System Is Brilliant \- TheHans255.com, 10月 9, 2025にアクセス、 [https://thehans255.com/blog/2025/06/deltarune-combat-system/](https://thehans255.com/blog/2025/06/deltarune-combat-system/)  
17. Add Text Input to Your Phaser 3 Game with RexUI, 10月 9, 2025にアクセス、 [https://phaser.io/news/2021/06/add-text-input-to-your-phaser-3-game-with-rexui](https://phaser.io/news/2021/06/add-text-input-to-your-phaser-3-game-with-rexui)  
18. Buttons \- Notes of Phaser 3 \- GitHub Pages, 10月 9, 2025にアクセス、 [https://rexrainbow.github.io/phaser3-rex-notes/docs/site/ui-buttons/](https://rexrainbow.github.io/phaser3-rex-notes/docs/site/ui-buttons/)  
19. Buttons in Phaser 3 \- Discourse, 10月 9, 2025にアクセス、 [https://phaser.discourse.group/t/buttons-in-phaser-3/1321](https://phaser.discourse.group/t/buttons-in-phaser-3/1321)  
20. Game Object Pools Tutorial \- Phaser, 10月 9, 2025にアクセス、 [https://phaser.io/news/2021/04/game-object-pools-tutorial](https://phaser.io/news/2021/04/game-object-pools-tutorial)  
21. Examples \- v3.85.0 \- pools \- Pool Using A Custom Class \- Phaser, 10月 9, 2025にアクセス、 [https://phaser.io/examples/v3.85.0/pools/view/pool-using-a-custom-class](https://phaser.io/examples/v3.85.0/pools/view/pool-using-a-custom-class)  
22. Phaser Coding Tips 7, 10月 9, 2025にアクセス、 [https://phaser.io/tutorials/coding-tips-007](https://phaser.io/tutorials/coding-tips-007)  
23. Pixel Art Aseprite Tutorials \- Lospec, 10月 9, 2025にアクセス、 [https://lospec.com/pixel-art-tutorials/tags/aseprite](https://lospec.com/pixel-art-tutorials/tags/aseprite)  
24. Recommended Pixel Art Tutorials? :: Aseprite General Discussion \- Steam Community, 10月 9, 2025にアクセス、 [https://steamcommunity.com/app/431730/discussions/0/3041607712749216815/?l=italian](https://steamcommunity.com/app/431730/discussions/0/3041607712749216815/?l=italian)  
25. How to start making pixel art \#3. A basic Aseprite animation | by Pedro Medeiros \- Medium, 10月 9, 2025にアクセス、 [https://medium.com/pixel-grimoire/how-to-start-making-pixel-art-3-c9eb70270fa1](https://medium.com/pixel-grimoire/how-to-start-making-pixel-art-3-c9eb70270fa1)  
26. Press Start 2P \- Google Fonts, 10月 9, 2025にアクセス、 [https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P)  
27. Pixelify Sans \- Google Fonts, 10月 9, 2025にアクセス、 [https://fonts.google.com/specimen/Pixelify+Sans](https://fonts.google.com/specimen/Pixelify+Sans)  
28. 20+ Best Pixel Perfect Fonts for 8-bit Designs for 2025 \- Onextrapixel, 10月 9, 2025にアクセス、 [https://onextrapixel.com/25-free-pixel-perfect-fonts-for-8-bit-designs/](https://onextrapixel.com/25-free-pixel-perfect-fonts-for-8-bit-designs/)  
29. 25+ Best 8-Bit Fonts (+ Backgrounds, Wallpapers and More) \- Design Shack, 10月 9, 2025にアクセス、 [https://designshack.net/articles/inspiration/8-bit-fonts/](https://designshack.net/articles/inspiration/8-bit-fonts/)  
30. Bfxr by isabelle adena kestrel \- itch.io, 10月 9, 2025にアクセス、 [https://iznaut.itch.io/bfxr](https://iznaut.itch.io/bfxr)  
31. Bfxr. Make sound effects for your games., 10月 9, 2025にアクセス、 [https://www.bfxr.net/](https://www.bfxr.net/)  
32. How to Make 8-Bit Sound Effects for YOUR Games using BFXR (FREE Download), 10月 9, 2025にアクセス、 [https://www.youtube.com/watch?v=JzuVP1WrMZg](https://www.youtube.com/watch?v=JzuVP1WrMZg)  
33. en.wikipedia.org, 10月 9, 2025にアクセス、 [https://en.wikipedia.org/wiki/Freesound](https://en.wikipedia.org/wiki/Freesound)  
34. Freesound.org Button \- Acoustica, 10月 9, 2025にアクセス、 [https://acoustica.com/mixcraft-10-manual/freesound-org-button](https://acoustica.com/mixcraft-10-manual/freesound-org-button)