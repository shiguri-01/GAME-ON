## Number-BATTLE-3: AI ロジック仕様書

この文書は `Number-BATTLE-3/js/ai.js` の動作を詳細に説明します。AI の意思決定アルゴリズム、使用されるヘルパー関数、評価関数、探索ロジック、優先順位付け、そして改善案までを含みます。

### 目的
AI モジュールは、AI のターンで行うべき行動（攻撃または分割）を決定し、UI アニメーションを呼び出した後にゲーム状態を更新してターンを切り替える責任を持ちます。外部からは `aiTurnWrapper(getState)` を呼ぶことで Promise を取得できます。Promise は AI のアニメーションと状態更新が完了したときに解決されます。

---

### 高レベルのフロー

1. 外部から `aiTurnWrapper(getState)` が呼ばれる。`getState()` は現在のゲーム状態（プレイヤー手、AI 手、gameOver など）を返す関数。
2. 現在の状態が既にゲーム終了なら何もせず解決。
3. `generateMovesFor('ai', rootState)` で可能な全ての手（攻撃・分割）を列挙。
4. もし手が無ければ分割アニメーションを実行してターン終了。
5. 速攻で勝利できる攻撃があれば即座にその攻撃をアニメーション付きで実行し、状態更新とターン切り替えを行う。
6. そうでなければ、アルファベータ探索（深さ 4）で各候補手を評価し、最良手を選択する。
7. 同点候補の多数決（優先ルール）で最終手を選び、アニメーションを実行して状態を更新する。

---

### 主要関数一覧（説明付き）

- randomChoice(arr)
  - 引数: 配列
  - 返り値: 配列からランダムな要素
  - 補足: あまり使われていないユーティリティ

- getAvailableHands(hands)
  - 引数: 2 要素の手配列
  - 返り値: アクティブ（0 でない）手のインデックス配列

- computePossibleSplits(total, current)
  - 引数: total (両手の合計), current (現在の手の配列)
  - 返り値: 合計を分割する可能なペアの配列（重複・同一分配は除外、各手は 0..4）
  - 振る舞い: si を 0 から total/2 までループして対の sj = total - si を作る。sj が 4 を超える場合は除外。

- cloneState(state)
  - 引数: state オブジェクト
  - 返り値: playerHands と aiHands を浅コピーした新しいオブジェクト

- checkWinState(state)
  - 引数: state
  - 返り値: { gameOver, playerLost, aiLost }
  - 判定: どちらかの手が両方 0（敗北）かどうかを見る

- simulateAttack(state, fromOwner, attackerIndex, toOwner, targetIndex)
  - 引数: ゲーム状態、攻撃側/防御側、攻撃手/対象手のインデックス
  - 振る舞い: 対象手の値を (attacker + target) % 5 に置き換えたクローン状態を返す
  - 返り値: 変更後のクローン状態（元 state は変更しない）

- simulateSplit(state, owner, val0, val1)
  - 引数: state, owner ('ai'|'player'), val0, val1
  - 振る舞い: 指定した owner の手を val0/val1 にセットしたクローン状態を返す

- evaluateState(state)
  - 引数: state
  - 返り値: 数値スコア（AI にとって高いほど良い）
  - ロジック:
    - もし playerLost -> +1_000_000 （AI 勝利）
    - もし aiLost -> -1_000_000 （AI 敗北）
    - アクティブな手の数差 (aiActive - playerActive) * 200
    - 合計値差 (aiSum - playerSum) * 10
    - 4 の手を持つ数の差 (aiHigh - playerHigh) * 50
    - バランス（差の絶対値が小さい方に微小ボーナス）

- generateMovesFor(owner, state)
  - 引数: owner ('ai'|'player'), state
  - 返り値: 可能な手の配列。攻撃は {type:'attack', ...}、分割は {type:'split', ...}
  - 補足: 攻撃は自分のアクティブな手から相手のアクティブな手へ。分割は computePossibleSplits に基づく。

- alphaBeta(state, depth, alpha, beta, maximizingPlayer)
  - 引数: state, 探索深さ depth, alpha, beta, 現在のプレイヤーが最大化プレイヤーかどうか
  - 戻り値: 評価値（evaluateState による）
  - 振る舞い: 通常の alpha-beta。各ノードで generateMovesFor を呼び、簡易的なムーブ順序付けのために evaluateState によって moves をソートする。

- aiTurnWrapper(getState)
  - 引数: getState() を呼ぶことで最新の状態が取得できる関数
  - 戻り値: Promise（アニメーションと状態更新完了で解決）
  - 振る舞い: 上述の高レベルフローに従って手を選び実行する。探索深さは SEARCH_DEPTH = 4。

---

### 評価関数の詳細

evaluateState は単純な加重ヒューリスティックで、次の特徴を持ちます:

- 終局の評価は極端な値で処理（+1e6 / -1e6）。探索結果で即時勝敗が見えた場合、局面を強く評価します。
- アクティブな手の数（0 でない手）の差を重視（200 倍）— 手数が多いほど選択肢が多い。
- 合計値差（各手の合計）を軽く考慮（10 倍）— 高い合計は強さの指標。
- 「4 を持っている手」の数をボーナス化（50 倍）— 4 の手は 1 回の攻撃で相手手を 0 にしやすく重要。
- バランス補正: AI 側が両手の差が小さい（バランスが良い）場合に微小ボーナス。

設計意図: 大きな構造（生存・有利）を優先しつつ、4 を作る（終局に直結する）ことを重視する。

---

### 探索とムーブ順序付け

- ルートノードでは generateMovesFor('ai') で全候補を列挙。
- 各候補について alphaBeta を実行し評価値を取得（SEARCH_DEPTH=4）。
- 同点候補は bestMoves 配列にまとめられ、最後に movePriority によって優先順位付けされる。

movePriority のルール:
- 攻撃かどうかで +1000
- 攻撃で即時勝利ならさらに +100000
- 攻撃によって 4 を作ると +200
- 分割で 4 を作ると +150
- 分割ではバランス度合い (10 - |val0 - val1|) を加算（差が小さいほど高い）

これにより攻撃（特に終局に近い攻撃）を優先し、分割は柔軟性（バランス）と 4 の生成に注目します。

---

### 典型的な意思決定シナリオ（例）

1. AI が (1,3)、プレイヤーが (2,3) の場合
   - 全攻撃候補を simulateAttack して即時勝利がないか確認。
   - alpha-beta により最も将来的に優位な手を選択。

2. AI が (4,0)、プレイヤーが (1,1) の場合
   - 4 を使った攻撃は強力。評価関数は 4 の存在を高く評価するため、攻撃が選ばれやすい。

3. AI が (2,2)、プレイヤーが (4,0) の場合
   - 相手に 4 があるため危険。評価関数は playerHigh を考慮するため、防御的な分割でバランスをとる手が出る可能性がある。

---

### 注意点・制約

- 探索深さは固定で 4。状態空間が大きくなる場合、計算コストが増大する。
- evaluateState は簡易ヒューリスティックで、戦術的な細かい読み（例えば相手の特定の反撃パターン）は完全には捉えない。
- computePossibleSplits は sj > 4 を除外する仕様だが、ゲームのルール変更があればここを調整する必要がある。

---

### 改善案（優先度付き）

1. 反復深化（iterative deepening）を導入して、時間制限内で可能な限り深く探索する。
2. トランスポジションテーブル（ハッシュ）を導入して状態の再評価を防ぎ、高速化する。
3. モンテカルロ木探索（MCTS）を試すことで、非決定的な評価関数でもロバストな手が見つかる可能性がある。
4. 評価関数の改善: 直近の勝利形（例えば特定の手順で相手の手が 0 になる確率）を局所評価として取り入れる。
5. ムーブ生成の微調整: 分割候補のフィルタリング（無意味な分割を削除）や、攻撃でターゲットとなる手の優先度付けを追加。

---

### 実装上の注意点

- アニメーション関数 `performAiAttackAnim`, `performAiSplitAnim` は UI 側で実際の表示を行い、コールバックで `applyAttack` / `applySplit` を呼んでいる。
- 実際の状態変更は `applyAttack`, `applySplit`, `switchTurnTo` により行われる。`aiTurnWrapper` 内で直接 state を変更するのではなく、これらのエクスポート関数を使って一貫した状態管理を行っている。
- `getState()` は常に最新の状態を返すことを期待しており、animate の完了後に `getState().checkWin()` を呼んで勝利判定を確認している。

---

### まとめ

`Number-BATTLE-3/js/ai.js` は、ミニマルだが実用的な alpha-beta ベースの AI を実装しています。評価関数はシンプルで高速、ムーブ選択では攻撃を優先するルールが入っています。現状のコードは小規模な改善（反復深化、トランスポジションテーブル、評価関数強化）で大きく強化できます。

もし希望があれば、上記の改善案の中から 1 つを選んで実装まで進めます — 例えば反復深化の導入やトランスポジションテーブルの追加など。
