## Number-BATTLE-3: AI（テーブルベース）仕様

この文書は `Number-BATTLE-3/ts/ai.ts` の現在の実装（テーブルベース参照型）を説明します。リファクタ後の AI は局面テーブル（chopsticks-tablebase.json）を参照して局所評価を行い、CPU 強度に基づく選択ポリシーを適用して最終手を決定します。

### 目的
AI モジュールは次を提供します:
- `aiTurnWrapper(getState)` — AI の行動を実行する非同期ラッパー。Promise を返し、アニメーションと状態更新が完了したら解決する。
- `getPlayerMovesAnalysis(state)` — プレイヤー視点での全手評価（ヒント用）。
- `getAIMovesAnalysisFromPlayerView(state)` — AI の手を列挙し、それらをプレイヤー視点で評価した結果（デバッグ/手動操作補助用）。

モジュールは局面テーブルを非同期でロードし、読み込み完了時に `window` に `tablebase-loaded` イベントを発行します。

### 高レベルのフロー

1. `aiTurnWrapper(getState)` が呼ばれる。
2. `getState()` で現在局面を取得。ゲーム終了なら何もせず終了。
3. 可能な全手を `generateMoves(...)` で列挙する。
4. テーブルベースが利用可能であれば、各候補手を `simulateMove` で適用した遷移局面（次ターン）を生成し、テーブルキーで参照して outcome/distance を取得する。
   - テーブルの outcome は「次ターンのプレイヤー視点」で格納されているため、AI の視点ではラベルを反転して扱う。
5. 取得した (move, outcome, distance) を WIN/DRAW/LOSS に分類し、CPU 強度（`CONFIG` や DOM の選択）に応じた選択ポリシーで最終手を決定する。
6. 選択手に応じた UI アニメーション（`performAiAttackAnim` / `performAiSplitAnim`）を呼び、アニメ完了コールバックで `applyAttack` / `applySplit` を実行、勝敗を確認してターンを切り替える。

### テーブルベース参照の考え方

- テーブルは正規化されたキー（各プレイヤーの手をソートし join した文字列 + 現在ターン）で索引され、対応する `outcome`（'WIN'/'LOSS'/'DRAW'）と `distance`（手数）を持ちます。
- AI は候補手を適用した後の「相手のターン」キーを参照し、テーブルの outcome を反転することで AI 視点の結果を得ます。

### CPU 強度ごとの選択ポリシー（実装の要点）

- `hard`:
  - 最優先: `WIN`（最短 distance を選ぶ）
  - 次: `DRAW`（ランダム）
  - 最後: `LOSS`（最も長く粘れるもの）

- `weak`:
  - 60%: 非負（WIN > DRAW > LOSS の順）を狙う
  - 40%: 故意に負け手を選ぶ（ただし distance >= 5 を優先）

- `normal` / その他:
  - WIN があれば 70% で勝ち手、20% で引き分け寄りの手、残りは損な手を選ぶ確率を導入
  - DRAW しか無ければ 90% で DRAW を選択

- `weakest`:
  - 可能な限り早く負ける手を選ぶ（ただしプレイヤーを即死させる手は回避する安全策あり）
  - プレイヤーが即勝ちできる手を優先して選ぶロジックを持つ

最近の変更:
- `weakest` モードでは、テーブルベース上またはシミュレーションで「プレイヤーが次の手で勝てる」手が存在する場合、それらを優先して選択するようになりました。即時勝ち手（プレイヤーの次のターンで AI の両手が 0 になる）を最優先します。存在しない場合は元の最弱ロジック（安全な手の選択やランダムフォールバック）にフォールバックします。

追加の更新:
- `weakest` モードで、さらに進めて「AI の一手後、プレイヤーがどの応答を選んでも結果としてプレイヤーが勝つ」ことがテーブルで確認できる手（強制勝ち）を最優先で選ぶようになりました。これにより、プレイヤーが故意に不利な手を選んだとしても、可能な場合はプレイヤー勝利を保証するよう試みます（ただし、テーブルが無い局面では判定不能のためフォールバックとなります）。

これらのポリシーは `selectMoveForStrength` に実装されています。

### 補助・安全ロジック

- `filterOutImmediatePlayerKills` で、AI の手がプレイヤーを即死させる（プレイヤーが次に動けない）手を除外して安全性を保つ場面がある。
- `findMovesAllowingImmediatePlayerWin` は、AI の候補手のうちプレイヤーに次の手で即勝ちを許すものを検出し、`weakest` で利用される。

### API と期待入力/出力

- `aiTurnWrapper(getState)`
  - getState(): ゲームのスナップショット（playerHands, aiHands, currentPlayer, gameOver, checkWin 等）を返す関数。
  - 返り値: Promise<void>（AI のアニメーションと状態更新が完了したら解決）

- `getPlayerMovesAnalysis(state)`
  - state: { playerHands, aiHands }
  - 返り値: null（テーブル未ロード）または [{ move, outcome, distance }]（プレイヤー視点での評価）

- `getAIMovesAnalysisFromPlayerView(state)`
  - state: { playerHands, aiHands }
  - 返り値: null（テーブル未ロード）または [{ move, outcome, distance }]（プレイヤー視点の評価：デバッグ/ヒント用）

### 実装上の注意点

- テーブルは非同期ロードされるため、UI は `tablebase-loaded` イベントを監視してヒントや再評価を行うべきです。
- テーブルに存在しないキーは `null` として扱われ、該当手はスコア対象外になります（フォールバックでランダム選択）。

### 改善案（現実的な順序）

1. テーブル未所持時のフォールバック強化（軽量評価関数）を追加してロード前の挙動を安定化。
2. テーブルサイズが大きい場合のメモリ/ロード最適化（圧縮・部分ロード）。
3. オンデマンドでテーブル（局面）をキャッシュする仕組みを追加。
4. UI 側に「テーブル未ロード」状態を明示してヒントの空表示とする。

---

この `ai.md` は `ts/ai.ts` の最新のコードに基づいて作成しました。追加で「選択ポリシーの挙動を可視化するログ」や「テーブルに無い局面のデバッグ出力」を実装することも可能です。


---

### まとめ

`Number-BATTLE-3/ts/ai.ts` は、ミニマルだが実用的な alpha-beta ベースの AI を実装しています。評価関数はシンプルで高速、ムーブ選択では攻撃を優先するルールが入っています。現状のコードは小規模な改善（反復深化、トランスポジションテーブル、評価関数強化）で大きく強化できます。

もし希望があれば、上記の改善案の中から 1 つを選んで実装まで進めます — 例えば反復深化の導入やトランスポジションテーブルの追加など。
