<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>沼 - 三段クルーンゲーム</title>
	<!-- TailwindCSS開発環境用 - 本番では適切なビルドプロセスを使用してください -->
	<script src="https://cdn.tailwindcss.com"></script>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #1a1a1a;
			color: white;
			font-family: 'Helvetica Neue', Arial, sans-serif;
		}

		#info-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			padding: 20px;
			box-sizing: border-box;
			text-align: center;
			pointer-events: none;
			/* UIが3D操作を妨げないようにする */
		}

		#controls {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			display: flex;
			gap: 10px;
		}

		button {
			background-color: #c0392b;
			color: white;
			border: none;
			padding: 12px 24px;
			border-radius: 8px;
			font-size: 16px;
			font-weight: bold;
			cursor: pointer;
			transition: background-color 0.3s, transform 0.1s;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
		}

		button:hover {
			background-color: #e74c3c;
		}

		button:active {
			transform: translateY(2px);
			box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2);
		}

		#message-box {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: rgba(0, 0, 0, 0.8);
			padding: 40px;
			border-radius: 15px;
			font-size: 48px;
			font-weight: bold;
			color: #f1c40f;
			display: none;
			/* 最初は非表示 */
			text-shadow: 2px 2px 4px #000;
			border: 3px solid #f1c40f;
		}
	</style>
</head>

<body>

	<div id="info-container" class="text-white">
		<h1 class="text-4xl font-bold mb-2 text-red-500" style="text-shadow: 2px 2px 4px #000;">沼</h1>
		<p class="text-lg">マウスドラッグで視点操作、スクロールでズーム</p>
	</div>

	<div id="controls">
		<button id="add-ball-btn">玉を発射</button>
	</div>

	<div id="message-box">大当たり！</div>

	<script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import * as CANNON from 'cannon-es';

		// --- 基本設定 ---
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(0, 30, 25);

		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		document.body.appendChild(renderer.domElement);

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;

		// --- ライティング ---
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		scene.add(ambientLight);

		const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
		directionalLight.position.set(10, 20, 5);
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.width = 2048;
		directionalLight.shadow.mapSize.height = 2048;
		directionalLight.shadow.camera.near = 1;
		directionalLight.shadow.camera.far = 60;
		directionalLight.shadow.camera.left = -15;
		directionalLight.shadow.camera.right = 15;
		directionalLight.shadow.camera.top = 15;
		directionalLight.shadow.camera.bottom = -15;
		directionalLight.shadow.bias = -0.0005;
		directionalLight.shadow.normalBias = 0.02;
		scene.add(directionalLight);

		// --- 物理ワールド ---
		const world = new CANNON.World({
			gravity: new CANNON.Vec3(0, -30, 0),
		});

		// 物理シミュレーションの安定性を向上
		world.defaultContactMaterial.contactEquationStiffness = 1e8; // さらに剛性を上げる
		world.defaultContactMaterial.contactEquationRelaxation = 3;
		world.solver.iterations = 15; // 反復回数を増やして精度向上
		world.solver.tolerance = 0.001; // 許容値を厳しくして貫通を防ぐ

		// 連続衝突検出を有効化
		world.allowSleep = false; // スリープモードを無効化してより確実な計算

		// --- マテリアル ---
		const ballMaterial = new CANNON.Material('ballMaterial');
		const wallMaterial = new CANNON.Material('wallMaterial');
		const groundMaterial = new CANNON.Material('groundMaterial');

		const ballWallContactMaterial = new CANNON.ContactMaterial(ballMaterial, wallMaterial, {
			friction: 0.1, // 摩擦を下げて滑らかな跳ね返り
			restitution: 0.6, // 反発係数を上げてより確実な跳ね返り
			contactEquationStiffness: 1e8, // 剛性を上げて貫通を防ぐ
			contactEquationRelaxation: 3,
		});
		world.addContactMaterial(ballWallContactMaterial);

		const ballGroundContactMaterial = new CANNON.ContactMaterial(ballMaterial, groundMaterial, {
			friction: 0.4,
			restitution: 0.2,
			contactEquationStiffness: 1e7,
		});
		world.addContactMaterial(ballGroundContactMaterial);

		// --- 削除予定のオブジェクトを管理する配列 ---
		const objectsToRemove = [];

		// --- クルーンの作成 ---
		const cruunRadius = 10;
		const cruunThickness = 0.2;
		const holeRadius = 0.8;
		const numHoles = 10;
		const cruunYPositions = [15, 7.5, 0];

		cruunYPositions.forEach((yPos, index) => {
			createCruun(new THREE.Vector3(0, yPos, 0), index);
		});

		function createCruun(position, stageIndex) {
			const cruunGroup = new THREE.Group();
			scene.add(cruunGroup);

			const tiltAngle = -Math.PI / 6;
			const tiltQuaternion = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), tiltAngle);

			const holePositions = [];
			for (let i = 0; i < numHoles; i++) {
				const angle = (i / numHoles) * Math.PI * 2;
				const holeX = Math.cos(angle) * (cruunRadius * 0.65);
				const holeZ = Math.sin(angle) * (cruunRadius * 0.65);
				holePositions.push({ x: holeX, z: holeZ });
			}

			// 1. Create the visual mesh (見た目用のモデル)
			const cruunShape = new THREE.Shape();
			cruunShape.absarc(0, 0, cruunRadius, 0, Math.PI * 2, false);
			const holeShapes = [];
			for (const holePos of holePositions) {
				const holePath = new THREE.Path();
				holePath.absarc(holePos.x, holePos.z, holeRadius, 0, Math.PI * 2, true);
				holeShapes.push(holePath);
			}
			cruunShape.holes = holeShapes;

			const extrudeSettings = { depth: cruunThickness, bevelEnabled: false };
			const geometry = new THREE.ExtrudeGeometry(cruunShape, extrudeSettings);
			const material = new THREE.MeshPhongMaterial({ color: '#888888', shininess: 10, specular: '#222222', side: THREE.DoubleSide });
			const cruunMesh = new THREE.Mesh(geometry, material);
			cruunMesh.castShadow = true;
			cruunMesh.receiveShadow = true;
			cruunMesh.rotation.x = -Math.PI / 2;
			cruunGroup.add(cruunMesh);

			// 2. Create the physics body using simple plane (シンプルで確実な物理ボディ)
			const cruunBody = new CANNON.Body({ mass: 0, material: groundMaterial });

			// 基本的な円盤を作成（穴は後でトリガーで処理）
			const diskRadius = cruunRadius;
			const diskThickness = cruunThickness;

			// 円盤を複数の薄いボックスで構成（より安定）
			const numSegments = 16;
			for (let i = 0; i < numSegments; i++) {
				const angle = (i / numSegments) * Math.PI * 2;
				const segmentLength = (Math.PI * 2 * diskRadius) / numSegments;
				const segmentX = Math.cos(angle) * diskRadius * 0.7; // 少し内側に配置
				const segmentZ = Math.sin(angle) * diskRadius * 0.7;

				const segmentShape = new CANNON.Box(new CANNON.Vec3(
					segmentLength / 4,
					diskThickness / 2,
					diskRadius * 0.4
				));

				const segmentRotation = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
				cruunBody.addShape(segmentShape, new CANNON.Vec3(segmentX, 0, segmentZ), segmentRotation);
			}

			// 中央部分も追加（より確実な接触面を提供）
			const centerShape = new CANNON.Cylinder(diskRadius * 0.6, diskRadius * 0.6, diskThickness, 16);
			cruunBody.addShape(centerShape);

			// 外周リングを追加（壁との隙間を埋める）
			const outerRingSegments = 24;
			for (let i = 0; i < outerRingSegments; i++) {
				const angle = (i / outerRingSegments) * Math.PI * 2;
				const ringRadius = diskRadius * 0.95; // 外周近くに配置
				const ringX = Math.cos(angle) * ringRadius;
				const ringZ = Math.sin(angle) * ringRadius;

				const ringSegmentLength = (Math.PI * 2 * ringRadius) / outerRingSegments;
				const ringShape = new CANNON.Box(new CANNON.Vec3(
					ringSegmentLength / 2,
					diskThickness / 2,
					diskThickness * 2 // 厚めにして確実な壁を作る
				));

				const ringRotation = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
				cruunBody.addShape(ringShape, new CANNON.Vec3(ringX, 0, ringZ), ringRotation);
			}

			world.addBody(cruunBody);			// 3. 外壁 (物理ボディのみ) - より確実な壁を作成
			const wallHeight = 4; // 壁の高さを大幅に増加
			const wallThickness = 1.0; // 壁の厚さを倍増
			const numWallSegments = 32; // セグメント数を倍増して隙間を削減

			// 外壁を複数のボックスで構成してより正確な円形にする
			for (let i = 0; i < numWallSegments; i++) {
				const angle = (i / numWallSegments) * Math.PI * 2;
				const nextAngle = ((i + 1) / numWallSegments) * Math.PI * 2;

				// 壁の位置を少し外側に配置して確実に囲む
				const wallRadius = cruunRadius + wallThickness / 2;
				const wallX = Math.cos(angle) * wallRadius;
				const wallZ = Math.sin(angle) * wallRadius;

				const wallBody = new CANNON.Body({ mass: 0, material: wallMaterial });

				// セグメントの長さを計算して隙間をなくす
				const segmentLength = 2 * Math.PI * wallRadius / numWallSegments;
				const wallShape = new CANNON.Box(new CANNON.Vec3(
					segmentLength / 2 * 1.1, // 少しオーバーラップさせる
					wallHeight / 2,
					wallThickness / 2
				));

				// 壁の向きを調整
				const wallRotation = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
				wallBody.addShape(wallShape, new CANNON.Vec3(0, 0, 0), wallRotation);

				// 外壁も同じように傾斜をつける
				const localWallPos = new CANNON.Vec3(wallX, wallHeight / 2, wallZ);
				const rotatedWallPos = tiltQuaternion.vmult(localWallPos);
				wallBody.position.copy(position).vadd(rotatedWallPos, wallBody.position);
				wallBody.quaternion.copy(tiltQuaternion);

				world.addBody(wallBody);
			}

			// 4. Position and tilt everything
			cruunGroup.position.copy(position);
			cruunBody.position.copy(position);

			cruunGroup.quaternion.copy(tiltQuaternion);
			cruunBody.quaternion.copy(tiltQuaternion);

			// 5. 当たり判定用のトリガーを設置（シンプルで確実）
			for (let i = 0; i < holePositions.length; i++) {
				const holePos = holePositions[i];
				const triggerShape = new CANNON.Cylinder(holeRadius, holeRadius, 3, 16);
				const triggerBody = new CANNON.Body({ isTrigger: true, mass: 0 });
				triggerBody.addShape(triggerShape);

				// トリガーの位置を正確に計算
				const localHolePos = new CANNON.Vec3(holePos.x, 0, holePos.z);
				const rotatedHolePos = tiltQuaternion.vmult(localHolePos);
				triggerBody.position.copy(position).vadd(rotatedHolePos, triggerBody.position);

				// トリガーの回転も合わせる
				triggerBody.quaternion.copy(tiltQuaternion);

				world.addBody(triggerBody);

				const isWinHole = (i === 0);
				triggerBody.addEventListener('collide', (event) => {
					const ballBody = event.body;
					if (ballBody.isBall) {
						const alreadyMarked = objectsToRemove.some(item => item.body === ballBody);
						if (!alreadyMarked) {
							objectsToRemove.push({ body: ballBody, mesh: ballBody.mesh });
							if (isWinHole) {
								if (stageIndex < cruunYPositions.length - 1) {
									addBall(cruunYPositions[stageIndex + 1] + 5);
								} else {
									showWinMessage();
								}
							}
						}
					}
				});
			}
		}

		// --- パチンコ玉 ---
		const balls = [];
		const ballRadius = 0.3; // 少し小さくして安定性向上
		const ballGeometry = new THREE.SphereGeometry(ballRadius, 16, 16); // ポリゴン数を減らして軽量化
		const ballThreeMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5, roughness: 0.1 });

		function addBall(startY = 22) {
			const ballMesh = new THREE.Mesh(ballGeometry, ballThreeMaterial);
			ballMesh.castShadow = true;
			ballMesh.receiveShadow = true;
			scene.add(ballMesh);

			const ballBody = new CANNON.Body({
				mass: 0.5, // 質量を軽くして安定性向上
				shape: new CANNON.Sphere(ballRadius),
				material: ballMaterial,
				linearDamping: 0.05, // 減衰を軽くして自然な動き
				angularDamping: 0.05
			});
			const randomX = (Math.random() - 0.5) * 2; // さらに範囲を狭める
			const randomZ = (Math.random() - 0.5) * 2;
			ballBody.position.set(randomX, startY, randomZ);
			world.addBody(ballBody);

			ballBody.isBall = true;
			ballBody.mesh = ballMesh;
			balls.push({ mesh: ballMesh, body: ballBody });
		}

		document.getElementById('add-ball-btn').addEventListener('click', () => addBall());

		// --- 大当たりメッセージ ---
		const messageBox = document.getElementById('message-box');
		function showWinMessage() {
			messageBox.style.display = 'block';
			setTimeout(() => { messageBox.style.display = 'none'; }, 3000);
		}

		// --- アニメーションループ ---
		const clock = new THREE.Clock();
		function animate() {
			requestAnimationFrame(animate);
			const deltaTime = Math.min(clock.getDelta(), 0.016); // 60FPSに制限
			world.step(1 / 60, deltaTime, 3); // 標準的な設定

			while (objectsToRemove.length > 0) {
				const item = objectsToRemove.pop();
				world.removeBody(item.body);
				scene.remove(item.mesh);
				const ballIndex = balls.findIndex(b => b.body === item.body);
				if (ballIndex > -1) { balls.splice(ballIndex, 1); }
			}

			balls.forEach(ball => {
				ball.mesh.position.copy(ball.body.position);
				ball.mesh.quaternion.copy(ball.body.quaternion);

				// ボールが下に落ちすぎた場合の処理
				if (ball.body.position.y < -15) {
					const alreadyMarked = objectsToRemove.some(item => item.body === ball.body);
					if (!alreadyMarked) { objectsToRemove.push({ body: ball.body, mesh: ball.mesh }); }
				}

				// ボールがクルーンの範囲外に出た場合の処理（すり抜け対策）
				const distanceFromCenter = Math.sqrt(ball.body.position.x * ball.body.position.x + ball.body.position.z * ball.body.position.z);
				if (distanceFromCenter > cruunRadius * 1.5 && ball.body.position.y > -5) {
					const alreadyMarked = objectsToRemove.some(item => item.body === ball.body);
					if (!alreadyMarked) {
						console.log('ボールが範囲外に出ました:', ball.body.position);
						objectsToRemove.push({ body: ball.body, mesh: ball.mesh });
					}
				}

				// ボールが停止したか判定（デバッグ用）
				const velocity = ball.body.velocity;
				const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
				if (speed < 0.1 && ball.body.position.y > -5) {
					// 停止したボールに少し力を加える
					ball.body.velocity.set(
						(Math.random() - 0.5) * 2,
						0,
						(Math.random() - 0.5) * 2
					);
				}
			}); controls.update();
			renderer.render(scene, camera);
		}

		// --- ウィンドウリサイズ対応 ---
		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});

		// --- 初期化 ---
		animate();
		addBall();
	</script>
</body>

</html>