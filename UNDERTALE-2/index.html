<!doctype html>
<html lang="ja">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>UNDERTALE ハート移動テスト</title>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
			rel="stylesheet"
		/>
		<style>
			/* ローカルのドットフォントを読み込む */
			@font-face {
				font-family: "JF Dot Shinonome";
				src: url("./assets/JF-Dot-ShinonomeMin14.ttf") format("truetype");
				font-weight: normal;
				font-style: normal;
				font-display: swap;
			}

			/* 余白をリセットし、描画の基準を揃える */
			* {
				box-sizing: border-box;
			}

			body {
				margin: 0;
				min-height: 100vh;
				display: flex;
				align-items: center;
				justify-content: center;
				background: #000;
				color: #f9f9f9;
				font-family: "JF Dot Shinonome", "Segoe UI", "Noto Sans JP", sans-serif;
			}

			/* ゲームUIを縦方向に並べるラッパー */
			#game-root {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 1rem;
			}

			/* シールド領域（初期 720px × 240px） */
			#playfield {
				width: 720px;
				height: 240px;
				border: 4px solid #f9f9f9;
				/* 滑らかなリサイズを有効にする */
				transition:
					width 260ms cubic-bezier(0.22, 0.9, 0.32, 1),
					height 260ms cubic-bezier(0.22, 0.9, 0.32, 1);
				position: relative;
				overflow: visible; /* 画面外からエンティティが入ってくるため */
				background: #111;
			}

			/* プレイフィールド上部に配置する敵シンボル表示領域 */
			#enemy-display {
				position: absolute;
				top: -56px;
				left: 50%;
				transform: translateX(-50%);
				display: flex;
				gap: 0.5rem;
				justify-content: center;
				align-items: center;
				font-size: 2.2rem;
				text-shadow: 0 0 6px rgba(0, 0, 0, 0.65);
				pointer-events: none;
			}

			#enemy-display img {
				width: 2.2rem;
				height: 2.2rem;
				object-fit: contain;
			}

			/* 各敵シンボルを横並びに揃える */
			.enemy-symbol {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				width: 2.2rem;
				height: 2.2rem;
				font-size: 2.2rem;
			}

			/* 可視オブジェクトをプレイフィールド上に重ねる基底クラス */
			.layer {
				position: absolute;
				inset: 0;
				overflow: visible;
				pointer-events: none; /* レイヤー自体はクリックできないようにする */
			}

			/* 敵エンティティを載せるレイヤー */
			#entity-layer {
				z-index: 1;
			}

			/* プレイヤー（ハート）用レイヤー */
			#player-layer {
				z-index: 2;
			}

			#player-overlay {
				position: absolute;
				top: 6px;
				left: 8px;
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
				font-size: 0.9rem;
				color: #fff;
				pointer-events: none;
			}

			/* デバッグ描画用レイヤー */
			#debug-layer {
				z-index: 4;
			}

			/* ハート本体のベーススタイル */
			#heart {
				position: absolute;
				width: var(--heart-size, 21px);
				height: var(--heart-size, 21px);
				pointer-events: none;
				user-select: none;
				transform: translate(0, 0);
				will-change: transform; /* パフォーマンス向上のため */
				/* 初期は非表示。Fight 押下で表示する */
				visibility: hidden;
			}

			/* 敵エンティティ共通スタイル */
			.entity {
				position: absolute;
				pointer-events: none;
				will-change: transform; /* パフォーマンス向上のため */
			}

			/* 円形エンティティ */
			.entity--circle {
				border-radius: 9999px;
			}

			/* 星形エンティティ */
			.entity--star {
				clip-path: polygon(
					50% 0%,
					61% 35%,
					98% 35%,
					68% 57%,
					79% 91%,
					50% 70%,
					21% 91%,
					32% 57%,
					2% 35%,
					39% 35%
				);
			}

			/* 三角形エンティティ */
			.entity--triangle {
				clip-path: polygon(50% 0%, 0% 86.6%, 100% 86.6%);
			}

			/* 操作説明のテキスト */
			#instruction {
				font-size: 0.95rem;
				text-align: left;
				opacity: 0.85;
				margin-top: 96px; /* スポーンラインより下に配置 */
			}

			#instruction > strong {
				display: block;
				text-align: center;
				margin-bottom: 0.4rem;
			}

			#instruction ul {
				list-style: disc;
				padding-left: 1.4rem;
				margin: 0;
			}

			#instruction li + li {
				margin-top: 0.25rem;
			}

			/* デバッグマーカーのスタイル */
			.debug-marker {
				mix-blend-mode: screen;
			}

			/* プレイヤー情報のステータス表示 */
			#player-status {
				width: 640px;
				--hp-offset: -24px;
				/* base font size for player status - change this to scale all labels */
				--player-font-size: 1.5rem;
				position: relative;
				margin-top: 1.75rem;
				margin-bottom: 0.6rem;
				padding: 0.6rem 1rem;
				display: grid;
				grid-template-columns: auto 240px auto;
				align-items: center;
				background: #000;
				border: 0;
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
				font-size: var(--player-font-size);
				font-weight: bold;
				letter-spacing: 0.04em;
			}

			#player-status .status-left,
			#player-status .status-right {
				display: inline-flex;
				align-items: center;
				gap: 0.8rem;
				padding: 0 0.5rem;
			}

			#player-status .status-name {
				font-weight: bold;
				color: #e6f7e6;
				font-size: var(--player-font-size);
			}

			#player-status .status-level {
				opacity: 0.9;
				font-weight: bold;
				font-size: var(--player-font-size);
			}

			#player-status .status-hp-value {
				font-weight: bold;
				min-width: 32px;
				text-align: right;
				color: #e6f7e6;
				font-size: var(--player-font-size);
			}

			#player-status .status-center {
				display: flex;
				flex-direction: row; /* ラベルをバーの左に並べる */
				align-items: center;
				gap: 0.75rem;
				justify-self: center; /* 中央カラムを中央に */
				transform: translateX(var(--hp-offset)); /* 少し左へ移動 */
			}

			#player-status .status-label {
				font-weight: bold;
				font-size: var(--player-font-size);
				color: #ffffff;
				min-width: 28px;
				text-align: left;
			}

			#player-status .status-hp-bar {
				position: relative;
				width: 175px; /* 約 240px の 0.7 倍 */
				height: 18px;
				border: 4px solid #ffffff; /* 白枠でプレイ画面と揃える */
				background: #222;
				border-radius: 2px;
				overflow: hidden;
			}

			#player-status .status-hp-fill {
				height: 100%;
				width: 100%; /* デフォルトは満タン表示。JSで aria 属性に基づき実サイズを設定します */
				background: linear-gradient(90deg, #d6b800, #e6d24a);
				transition: width 180ms ease;
			}

			/* large typographic styles to match reference */
			.status-left .status-level {
				font-weight: 900;
				/* keep a slightly smaller display for the LV label compared to base */
				font-size: calc(var(--player-font-size) * 0.76);
				letter-spacing: 0.06em;
			}

			.status-right {
				justify-self: end;
				font-weight: 800;
				font-size: calc(var(--player-font-size) * 0.57);
			}

			/* 行動選択ボタンのコンテナ */
			#action-menu {
				width: 640px;
				display: flex;
				justify-content: space-between;
				gap: 1.5rem;
				margin-bottom: 1.6rem;
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
			}

			.action-button {
				flex: 1;
				display: inline-flex;
				align-items: center; /* vertical centering */
				justify-content: flex-start; /* left align content */
				white-space: nowrap; /* prevent emoji/label wrapping */
				gap: 0.6ch;
				padding: 0.9rem 0 0.9rem 1rem; /* top/right/bottom/left - give left padding for icon */
				background: #000;
				color: #ff9c1a;
				border: 4px solid #ff9c1a;
				text-transform: uppercase;
				letter-spacing: 0.08em;
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
				font-size: var(--action-button-font-size, 0.95rem);
				/* keep a small indentation for legacy layouts; labels are now in .action-label */
				text-indent: 0ch;
				cursor: pointer;
				box-shadow: 0 0 0 1px #000 inset;
				transition:
					transform 120ms ease,
					box-shadow 120ms ease;
			}

			.action-button:hover,
			.action-button:focus-visible {
				transform: translateY(-2px);
				box-shadow:
					0 0 0 1px #ff9c1a inset,
					0 6px 12px rgba(0, 0, 0, 0.35);
				outline: none;
			}

			/* icon inside action button - can be replaced with an <img> later */
			.action-icon {
				display: inline-flex;
				align-items: center; /* vertically center emoji */
				justify-content: center;
				width: 1.4em; /* reserve space similar to typical emoji width */
				height: 1.2em;
				font-size: 1.1em;
				text-align: center;
			}

			/* if aria-hidden is true, hide the icon visually but keep its layout space */
			.action-icon[aria-hidden="true"] {
				visibility: hidden; /* preserves the element's width so label doesn't shift */
			}

			.action-button img.action-icon-img {
				width: 1.4em;
				height: 1em;
				object-fit: contain;
				display: inline-block;
				vertical-align: middle;
			}

			.action-button svg.action-icon-svg {
				width: 1.4em;
				height: 1em;
				display: inline-block;
				vertical-align: middle;
			}

			.action-label {
				display: inline-flex;
				align-items: center; /* vertically center label */
				height: 1.2em;
			}

			.action-button:active {
				transform: translateY(0);
				box-shadow:
					0 0 0 1px #ff9c1a inset,
					0 2px 4px rgba(0, 0, 0, 0.4);
			}

			/* selected state when navigating with keyboard */
			.action-button.selected {
				/* visually lift and highlight the selected button */
				transform: translateY(-2px);
				box-shadow:
					0 0 0 2px #ffffff inset,
					0 6px 12px rgba(0, 0, 0, 0.25);
			}

			/* white framed box removed per user request */

			/* Game Over overlay - hidden by default */
			#gameover-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: #000;
				color: #fff;
				display: flex;
				align-items: center;
				justify-content: center;
				/* ドットフォント優先 */
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
				font-size: 3.2rem;
				letter-spacing: 0.08em;
				z-index: 9999;
				opacity: 0;
				pointer-events: none;
				transform: scale(0.88);
				/* アニメーションの詳細は keyframes で設定 */
			}

			#gameover-overlay[aria-hidden="false"] {
				pointer-events: auto;
				animation: gameover-entrance 420ms cubic-bezier(0.22, 0.9, 0.32, 1) both;
			}

			@keyframes gameover-entrance {
				0% {
					opacity: 0;
					transform: scale(0.88) translateZ(0);
				}
				60% {
					opacity: 1;
					transform: scale(1.06) translateZ(0);
				}
				100% {
					opacity: 1;
					transform: scale(1) translateZ(0);
				}
			}

			/* gameover inner layout */
			.gameover-inner {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 1.2rem;
			}

			.gameover-title {
				font-size: 3.2rem;
				font-weight: 700;
			}

			#retry-button {
				background: #fff;
				color: #000;
				border: 0;
				padding: 0.8rem 1.2rem;
				font-family:
					"JF Dot Shinonome", "Noto Sans JP", "Hiragino Kaku Gothic ProN",
					"Yu Gothic", "Meiryo", "Segoe UI", sans-serif;
				font-size: 0.9rem;
				cursor: pointer;
				border-radius: 4px;
				box-shadow: 0 4px 0 rgba(0, 0, 0, 0.6);
			}

			#retry-button:active {
				transform: translateY(2px);
				box-shadow: 0 2px 0 rgba(0, 0, 0, 0.6);
			}
		</style>
	</head>
	<body>
		<div id="game-root">
			<!-- ゲーム画面 -->
			<div id="playfield">
				<!-- 敵を絵文字で表現する静的表示領域 -->
				<div id="enemy-display"></div>
				<!-- エンティティ（敵など）を描画するレイヤー -->
				<div class="layer" id="entity-layer"></div>
				<!-- プレイヤー（ハート）を描画するレイヤー -->
				<div class="layer" id="player-layer">
					<div id="heart"></div>
					<div id="player-overlay">テスト</div>
				</div>
			</div>
			<!-- プレイヤー情報 -->
			<div id="player-status" role="group" aria-label="プレイヤー情報">
				<div class="status-left">
					<span class="status-name">Chra</span>
					<span class="status-level"
						><span class="status-label">LV</span> 1</span
					>
				</div>
				<div class="status-center">
					<span class="status-label">HP</span>
					<div
						class="status-hp-bar"
						role="progressbar"
						aria-valuenow="20"
						aria-valuemin="0"
						aria-valuemax="20"
					>
						<div class="status-hp-fill"></div>
					</div>
				</div>
				<div class="status-right">
					<span class="status-hp-value" aria-hidden="false"
						>20&nbsp;/&nbsp;20</span
					>
				</div>
			</div>
			<div id="action-menu" role="group" aria-label="行動選択">
				<button class="action-button" type="button">
					<span class="action-icon" aria-hidden="false">⚔️</span
					><span class="action-label">FIGHT</span>
				</button>
				<button class="action-button" type="button">
					<span class="action-icon" aria-hidden="false">🗨️</span
					><span class="action-label">ACT</span>
				</button>
				<button class="action-button" type="button">
					<span class="action-icon" aria-hidden="false">💰</span
					><span class="action-label">ITEM</span>
				</button>
				<button class="action-button" type="button">
					<span class="action-icon" aria-hidden="false">❌</span
					><span class="action-label">MERCY</span>
				</button>
			</div>
			<!-- 操作説明 -->
			<div id="instruction">
				<strong>操作方法（キー一覧）:</strong>
				<ul>
					<li>
						<strong>移動:</strong> 矢印キー または
						<code>W</code>/<code>A</code>/<code>S</code>/<code>D</code>
						でハートを上下左右に移動。長押しで継続移動できます。
					</li>
					<li>
						<strong>行動選択:</strong> 左右の矢印キー（← /
						→）で選択を移動します。Enter / Space
						で決定、もしくはマウスでボタンをクリックできます。行動選択中は選択中のボタンがハイライトされます。
					</li>
					<li>
						<strong>スポーンパターン:</strong> 数字キー <code>1</code> /
						<code>2</code> でスポーンパターンを切り替えます。
					</li>
					<li>
						<strong>デバッグ表示:</strong>
						<code>M</code> でデバッグ表示のオン/オフを切り替えます。
					</li>
					<li>
						<strong>スポーンマーカー:</strong>
						<code>P</code> でスポーンマーカーの表示を切り替えます。
					</li>
					<li>
						<strong>削除モード:</strong>
						<code>T</code>
						で、衝突時にエンティティを即時削除するモードのオン/オフを切り替えます（衝突挙動のテスト用）。
					</li>
					<li>
						<strong>プレイフィールド幅:</strong> <code>Q</code> /
						<code>E</code> で幅をそれぞれ小さく / 大きく調整します。
					</li>
					<li>
						<strong>プレイフィールド高さ:</strong> <code>R</code> /
						<code>F</code> で高さをそれぞれ小さく / 大きく調整します。
					</li>
					<li>
						<strong>ハート色（デバッグ）:</strong>
						<code>G</code>
						を押すとデバッグ用にハートの色が切り替わります。切り替えは行動選択のハート表示にも反映されます。
					</li>
					<li>
						<strong>注意:</strong>
						エンティティのスポーン中は行動選択のキーボードナビゲーションが一時的に無効化されます（スポーン終了時に自動で再有効化されます）。
					</li>
				</ul>
			</div>
		</div>

		<!-- Game Over オーバーレイ -->
		<div id="gameover-overlay" aria-hidden="true">
			<div class="gameover-inner">
				<div class="gameover-title">GAMEOVER</div>
				<button id="retry-button" type="button" aria-label="Retry">
					RETRY
				</button>
			</div>
		</div>

		<!-- メインのスクリプトを読み込み -->
		<script type="module" src="ts/main.ts"></script>
		<!-- HPバーの初期表示を aria 属性に基づき反映する小さな初期化スクリプト -->
		<script>
			(function initHpBar() {
				const bar = document.querySelector(
					'#player-status .status-hp-bar[role="progressbar"]',
				);
				const fill = bar?.querySelector(".status-hp-fill");
				if (!bar || !fill) return;
				const now = Number(bar.getAttribute("aria-valuenow") ?? 0);
				const max = Number(bar.getAttribute("aria-valuemax") ?? 100);
				const pct =
					!isFinite(now) || !isFinite(max) || max <= 0 ? 0 : (now / max) * 100;
				fill.style.width = pct + "%";
			})();

			// When player heart is shown, ensure selection images are suppressed and replaced with emoji
			document.addEventListener("player:heartShown", () => {
				const buttons = Array.from(
					document.querySelectorAll("#action-menu .action-button"),
				);
				buttons.forEach((b) => {
					const icon = b.querySelector(".action-icon");
					if (!icon) return;
					const usesHeartIcon = icon.getAttribute("data-heart-icon") === "true";
					if (!usesHeartIcon) return;
					// if icon contains an img, remove it and restore emoji
					const img = icon.querySelector("img.action-icon-img");
					if (img) {
						img.remove();
						icon.textContent = icon.getAttribute("data-emoji") || "";
						icon.removeAttribute("aria-hidden");
						icon.removeAttribute("data-heart-icon");
					}
					const svg = icon.querySelector("svg.action-icon-svg");
					if (svg) {
						svg.remove();
						icon.textContent = icon.getAttribute("data-emoji") || "";
						icon.removeAttribute("aria-hidden");
						icon.removeAttribute("data-heart-icon");
					}
				});
			});

			// Show GAMEOVER overlay when gameover event is dispatched
			document.addEventListener("gameover", () => {
				const overlay = document.getElementById("gameover-overlay");
				if (!overlay) return;
				overlay.setAttribute("aria-hidden", "false");
				const retry = document.getElementById("retry-button");
				if (retry instanceof HTMLElement) {
					retry.focus();
					retry.addEventListener("click", () => {
						window.location.reload();
					});
				}
			});

			// Allow pressing 'R' to retry when gameover overlay is visible
			document.addEventListener("keydown", (e) => {
				if (e.key.toLowerCase() === "r") {
					const overlay = document.getElementById("gameover-overlay");
					if (overlay?.getAttribute("aria-hidden") === "false") {
						window.location.reload();
					}
				}
			});

			// Action menu icon management API
			// Provides runtime helpers to replace the icon (emoji) with an image
			// or to toggle its visibility. Use e.g.:
			// window.actionMenu.setIcon(0, 'icons/fight.png')
			// window.actionMenu.showIcon(1, false)
			(function () {
				const buttons = Array.from(
					document.querySelectorAll("#action-menu .action-button"),
				);
				function getIconEl(idx) {
					const btn = buttons[idx];
					if (!btn) return null;
					return btn.querySelector(".action-icon");
				}

				window.actionMenu = {
					setIcon(idx, imgSrc) {
						const icon = getIconEl(idx);
						if (!icon) return;
						// replace inner content with an <img> having the action-icon-img class
						const existingSvg = icon.querySelector("svg.action-icon-svg");
						if (existingSvg) existingSvg.remove();
						const img = document.createElement("img");
						img.src = imgSrc;
						img.className = "action-icon-img";
						img.alt = "";
						icon.textContent = "";
						icon.appendChild(img);
						icon.removeAttribute("data-heart-icon");
					},
					clearIcon(idx) {
						const icon = getIconEl(idx);
						if (!icon) return;
						const existingSvg = icon.querySelector("svg.action-icon-svg");
						if (existingSvg) existingSvg.remove();
						const existingImg = icon.querySelector("img.action-icon-img");
						if (existingImg) existingImg.remove();
						icon.textContent = icon.getAttribute("data-emoji") || "";
						icon.removeAttribute("data-heart-icon");
						icon.removeAttribute("aria-hidden");
					},
					showIcon(idx, visible = true) {
						const icon = getIconEl(idx);
						if (!icon) return;
						// set aria-hidden for accessibility and allow CSS to hide the element
						icon.setAttribute("aria-hidden", visible ? "false" : "true");
					},
				};
				// preserve original emoji as data attribute for clearIcon
				buttons.forEach((b) => {
					const icon = b.querySelector(".action-icon");
					if (icon && icon.textContent)
						icon.setAttribute("data-emoji", icon.textContent.trim());
				});
			})();

			// Keyboard navigation for action menu
			(function () {
				const menu = document.getElementById("action-menu");
				if (!menu) return;
				const buttons = Array.from(menu.querySelectorAll(".action-button"));
				let selectedIndex = 0;
				let navEnabled = true; // when false, arrow-key selection is ignored (e.g., during spawning)
				const SVG_NS = "http://www.w3.org/2000/svg";
				const HEART_ICON_VIEWBOX = "0 0 476.36792 399.95195";
				const HEART_ICON_PATH =
					"m 238.15,437.221 v 0 C 449.09,352.067 530.371,154.668 437.481,69.515 344.582,-15.639 238.15,100.468 238.15,100.468 h -0.774 c 0,0 -106.44,-116.107 -199.331,-30.953 -92.889,85.143 -10.834,282.553 200.105,367.706 z";
				const DEFAULT_HEART_COLOR = "hsl(0 100% 50%)";
				let heartColor = DEFAULT_HEART_COLOR;

				function isHeartVisible() {
					const heartEl = document.getElementById("heart");
					return Boolean(heartEl && heartEl.style.visibility === "visible");
				}

				function createHeartIconSvg(color) {
					const svg = document.createElementNS(SVG_NS, "svg");
					svg.setAttribute("viewBox", HEART_ICON_VIEWBOX);
					svg.setAttribute("class", "action-icon-svg");
					svg.setAttribute("role", "presentation");
					svg.setAttribute("focusable", "false");
					const path = document.createElementNS(SVG_NS, "path");
					path.setAttribute("d", HEART_ICON_PATH);
					// apply the original SVG's translate to vertically align the path inside the viewBox
					path.setAttribute("transform", "translate(0.34846644,-37.808257)");
					path.setAttribute("fill", color);
					path.setAttribute("stroke", "#000");
					path.setAttribute("stroke-width", "10");
					path.setAttribute("stroke-linejoin", "round");
					svg.appendChild(path);
					return svg;
				}

				function restoreIcon(iconEl) {
					if (!iconEl) return;
					if (iconEl.getAttribute("data-heart-icon") !== "true") return;
					const existingSvg = iconEl.querySelector("svg.action-icon-svg");
					if (existingSvg) existingSvg.remove();
					const existingImg = iconEl.querySelector("img.action-icon-img");
					if (existingImg) existingImg.remove();
					iconEl.textContent = iconEl.getAttribute("data-emoji") || "";
					iconEl.removeAttribute("aria-hidden");
					iconEl.removeAttribute("data-heart-icon");
				}

				function applyHeartIcon(iconEl) {
					if (!iconEl) return;
					const existingSvg = iconEl.querySelector("svg.action-icon-svg");
					if (existingSvg) {
						const path = existingSvg.querySelector("path");
						if (path instanceof SVGGeometryElement) {
							path.setAttribute("fill", heartColor);
						}
						iconEl.setAttribute("aria-hidden", "false");
						iconEl.setAttribute("data-heart-icon", "true");
						return;
					}
					iconEl.textContent = "";
					iconEl.appendChild(createHeartIconSvg(heartColor));
					iconEl.setAttribute("aria-hidden", "false");
					iconEl.setAttribute("data-heart-icon", "true");
				}

				function syncSelectionHeartIcons(color) {
					const paths = document.querySelectorAll(
						"#action-menu svg.action-icon-svg path",
					);
					paths.forEach((path) => {
						if (!(path instanceof SVGGeometryElement)) return;
						const wrapper = path.closest(".action-icon");
						if (!wrapper || wrapper.getAttribute("data-heart-icon") !== "true")
							return;
						path.setAttribute("fill", color);
					});
				}

				function updateSelection(newIndex) {
					if (newIndex < 0) newIndex = 0;
					if (newIndex >= buttons.length) newIndex = buttons.length - 1;
					if (selectedIndex === newIndex) return;
					// remove previous
					buttons[selectedIndex].classList.remove("selected");
					const prevIcon = buttons[selectedIndex].querySelector(".action-icon");
					if (prevIcon) restoreIcon(prevIcon);
					// apply new
					selectedIndex = newIndex;
					buttons[selectedIndex].classList.add("selected");
					const newIcon = buttons[selectedIndex].querySelector(".action-icon");
					if (newIcon) {
						if (isHeartVisible()) {
							restoreIcon(newIcon);
						} else {
							applyHeartIcon(newIcon);
						}
					}
					// ensure focus for accessibility
					const btn = buttons[selectedIndex];
					if (btn instanceof HTMLElement) btn.focus({ preventScroll: true });
				}

				// initialize selection: hide the icon of initial selection
				buttons.forEach((b) => b.classList.remove("selected"));
				if (buttons.length) {
					buttons[selectedIndex].classList.add("selected");
					const initIcon = buttons[selectedIndex].querySelector(".action-icon");
					if (initIcon) {
						if (!isHeartVisible()) {
							applyHeartIcon(initIcon);
						} else {
							restoreIcon(initIcon);
						}
					}
				}

				// keyboard handling
				document.addEventListener("keydown", (e) => {
					const key = e.key;
					// If navigation is disabled (e.g., entities spawning), ignore arrow/A/D input
					if (
						!navEnabled &&
						(key === "ArrowLeft" ||
							key === "ArrowRight" ||
							key === "a" ||
							key === "A" ||
							key === "d" ||
							key === "D")
					) {
						return;
					}
					if (key === "ArrowLeft" || key === "a" || key === "A") {
						e.preventDefault();
						updateSelection(selectedIndex - 1);
					} else if (key === "ArrowRight" || key === "d" || key === "D") {
						e.preventDefault();
						updateSelection(selectedIndex + 1);
					} else if (key === "Enter" || key === " ") {
						// activate current button
						e.preventDefault();
						const btn = buttons[selectedIndex];
						if (btn) btn.click();
					}
				});

				// Listen for spawning start/stop events to disable/enable navigation
				document.addEventListener("game:spawningStarted", () => {
					navEnabled = false;
				});
				document.addEventListener("game:spawningStopped", () => {
					navEnabled = true;
				});

				document.addEventListener("player:heartColorChange", (event) => {
					const nextColor = event?.detail?.color;
					if (typeof nextColor === "string" && nextColor) {
						heartColor = nextColor;
						syncSelectionHeartIcons(heartColor);
					}
				});

				// click-to-select: clicking a button will set selection and trigger its action
				buttons.forEach((b, idx) => {
					b.addEventListener("click", (ev) => {
						// If clicked while not selected, just update selection; if already selected, allow normal click action
						if (selectedIndex !== idx) {
							ev.preventDefault();
							updateSelection(idx);
							return;
						}
						// if selected, proceed with default click behavior (no-op here, but keeps semantics)
					});
				});
			})();
		</script>
	</body>
</html>
