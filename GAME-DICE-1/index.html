<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>3Dチンチロ</title>
	<!-- Tailwind CDN removed to avoid production warning in console.
		 For production, consider installing Tailwind via npm and building a CSS bundle.
		 See https://tailwindcss.com/docs/installation if you want me to set that up. -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">
	<style>
		body {
			margin: 0;
			overflow: hidden;
			font-family: 'Shippori Mincho', serif;
			background-color: #333;
			color: #fff;
		}

		#canvas-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			cursor: pointer;
		}

		#ui-container {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			padding: 20px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center;
			background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
			pointer-events: none;
		}

		.action-button {
			pointer-events: auto;
			font-size: 1.2rem;
			font-weight: 700;
			padding: 12px 28px;
			border-radius: 8px;
			cursor: pointer;
			color: white;
			border: none;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
			transition: all 0.1s ease-in-out;
		}

		.action-button:hover {
			transform: translateY(-2px);
			box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
		}

		.action-button:active {
			transform: translateY(1px);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
		}

		.action-button:disabled {
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		#rollButton {
			background: linear-gradient(145deg, #e74c3c, #c0392b);
			border-bottom: 4px solid #962d22;
		}

		#rollButton:hover {
			background: linear-gradient(145deg, #ff6b5a, #d35400);
		}

		#rollButton:active {
			border-bottom-width: 2px;
		}

		#rollButton:disabled {
			background: #7f8c8d;
			border-bottom: 4px solid #647071;
		}

		.top-button {
			display: none;
			position: absolute;
			top: 20px;
			z-index: 10;
			font-size: 1rem;
			padding: 8px 16px;
		}

		#nudgeButton {
			left: 50%;
			transform: translateX(-50%);
			background: linear-gradient(145deg, #3498db, #2980b9);
			border-bottom: 4px solid #216a9a;
		}

		#nudgeButton:hover {
			background: linear-gradient(145deg, #5dade2, #3498db);
		}

		#nudgeButton:active {
			border-bottom-width: 2px;
		}

		#rearrangeButton {
			left: 20px;
			background: linear-gradient(145deg, #2ecc71, #27ae60);
			border-bottom: 4px solid #1e8449;
		}

		#rearrangeButton:hover {
			background: linear-gradient(145deg, #58d68d, #2ecc71);
		}

		#rearrangeButton:active {
			border-bottom-width: 2px;
		}

		#diceTypeSelector {
			pointer-events: auto;
			position: absolute;
			top: 20px;
			right: 20px;
			z-index: 10;
			font-family: 'Shippori Mincho', serif;
			font-size: 1rem;
			padding: 8px 12px;
			border-radius: 8px;
			color: white;
			border: 2px solid #7f8c8d;
			background-color: #34495e;
			cursor: pointer;
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
			background-position: right 0.5rem center;
			background-repeat: no-repeat;
			background-size: 1.5em 1.5em;
			padding-right: 2.5rem;
		}

		#diceTypeSelector:disabled {
			background-color: #7f8c8d;
			cursor: not-allowed;
			opacity: 0.7;
		}

		#result-display {
			height: 80px;
			margin-bottom: 15px;
			display: flex;
			flex-direction: column;
			justify-content: center;
		}

		#result-title {
			font-size: 2.5rem;
			font-weight: 700;
			color: #f1c40f;
			text-shadow: 0 0 5px rgba(241, 196, 15, 0.5), 0 0 15px rgba(0, 0, 0, 0.7);
			margin: 0;
			transition: all 0.3s ease;
		}

		#result-description {
			font-size: 1.1rem;
			color: #ecf0f1;
			text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
			margin: 5px 0 0 0;
			min-height: 1.5em;
		}

		#power-meter-container {
			width: 80%;
			max-width: 400px;
			height: 20px;
			background-color: rgba(0, 0, 0, 0.5);
			border: 2px solid #aaa;
			border-radius: 10px;
			margin-bottom: 20px;
			overflow: hidden;
			display: none;
			box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
		}

		#power-meter-bar {
			width: 0%;
			height: 100%;
			background: linear-gradient(to right, #f1c40f, #e74c3c);
			border-radius: 8px;
			transition: width 0.05s linear;
		}
	</style>
</head>

<body>

	<div id="canvas-container"></div>
	<select id="diceTypeSelector">
		<option value="normal">通常賽</option>
		<option value="shigoro">四五六賽</option>
		<option value="pinzoro">ピンゾロ賽</option>
	</select>
	<button id="nudgeButton" class="action-button top-button">揺らす</button>
	<button id="rearrangeButton" class="action-button top-button">再配置</button>


	<div id="ui-container">
		<div id="result-display">
			<h1 id="result-title">チンチロ</h1>
			<p id="result-description">下のボタンで投擲準備</p>
		</div>
		<div id="power-meter-container">
			<div id="power-meter-bar"></div>
		</div>
		<button id="rollButton" class="action-button">サイコロを振る</button>
	</div>

	<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

	<!-- Tone.js is loaded via this UMD script tag, making it available as `window.Tone` -->
	<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>

	<script type="module">
		// =================================================================================
		// チンチロリン - 3D
		//
		// 伝統的な日本のゲーム「チンチロリン」を基にした3Dサイコロゲーム。
		// レンダリングにThree.js、物理演算にcannon-es.js、音声にTone.jsを使用。
		// =================================================================================        
		import * as THREE from 'three';
		import * as CANNON from 'cannon-es';
		// Tone is loaded via UMD script tag above and available as window.Tone
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		// =================================================================================
		// DOM要素
		// =================================================================================
		const canvasContainer = document.getElementById('canvas-container');
		const rollButton = document.getElementById('rollButton');
		const nudgeButton = document.getElementById('nudgeButton');
		const rearrangeButton = document.getElementById('rearrangeButton');
		const diceTypeSelector = document.getElementById('diceTypeSelector');
		const resultTitle = document.getElementById('result-title');
		const resultDescription = document.getElementById('result-description');
		const powerMeterContainer = document.getElementById('power-meter-container');
		const powerMeterBar = document.getElementById('power-meter-bar');

		// =================================================================================
		// グローバル状態と定数
		// =================================================================================
		// Three.js related variables
		let scene, camera, renderer, controls, clock;
		// Physics world
		let world;
		// Arrays to hold dice objects (visual and physical)
		const dice = [];
		const diceBodies = [];

		// --- ゲーム定数 ---
		const diceSize = 0.5;   // 各サイコロのサイズ
		const bowlRadius = 4;   // 丼の半径
		const bowlHeight = 2;   // 丼の壁の高さ

		// --- ゲーム状態管理 ---
		// ゲームの流れを管理（例: 'initializing', 'ready', 'charging', 'rolling', 'checking'）
		let gameState = 'initializing';
		let diceType = 'normal'; // 使用中のサイコロの種類
		let rollStartTime = 0;   // ロール開始時のタイムスタンプ、スタック検出に使用

		// --- ゲームルールとタイマー ---
		const STUCK_THRESHOLD_MS = 5000; // サイコロがスタックした場合に「揺らす」ボタンが表示されるまでの時間
		const SHONBEN_GRACE_PERIOD_MS = 100; // サイコロが丼から出た後、「ションベン」と見なされるまでの猶予期間
		let shonbenTimers = [0, 0, 0]; // 各サイコロの猶予期間を追跡するタイマー

		// --- パワーメーター ---
		let power = 0; // 現在のパワーレベル
		let powerDirection = 1; // パワーメーターアニメーションの方向（1で増加、-1で減少）
		let powerAnimationId = null; // パワーメーターのrequestAnimationFrameループのID

		/**
		 * @class SoundManager
		 * @description Why: サウンド関連のすべてのロジックをこのクラスにカプセル化することで、
		 * 音声システムの関心をゲームの主要なロジックから分離します。これにより、コードの整理、保守、拡張が容易になります。
		 */
		class SoundManager {
			constructor() {
				this.isInitialized = false;
				
				// SOUND REDESIGN #3: Single, re-tuned synth for the "karan karan" effect.
				this.clinkSynth = null; 

				this.winSynth = null;
				this.pairSynth = null;
				this.loseSynth = null;
				this.foulSynth = null;
				this.clickSynth = null;
				this._lastPlay = {}; // timestamps for throttling sounds

				// DYNAMIC SOUND: Constants for tuning impact response.
				this.MAX_IMPACT_VELOCITY_DICE = 20; // サイコロ同士の衝突で想定される最大衝撃速度
				this.MAX_IMPACT_VELOCITY_BOWL = 25; // サイコロと丼の衝突で想定される最大衝撃速度
			}

			// internal helper: get current time in seconds
			_now() {
				return Tone.now();
			}

			// throttle by key (seconds)
			_canPlay(key, minIntervalSec = 0.03) {
				const now = this._now();
				const last = this._lastPlay[key] || 0;
				if (now - last >= minIntervalSec) { this._lastPlay[key] = now; return true; }
				return false;
			}

			// Why: 多くのブラウザでは、音声の再生を開始する前にユーザーの操作が必要です。
			// このメソッドは、最初のクリックで安全にTone.jsを初期化するために使用されます。
			async init() {
				if (this.isInitialized) return;
				if (typeof Tone === 'undefined' || !Tone) {
					console.warn('SoundManager: Tone.js not found on window; sound disabled.');
					this.isInitialized = true; // Mark as initialized to prevent retries
					return;
				}

				try {
					await Tone.start();
				} catch (e) {
					console.warn('SoundManager: Tone.start() failed. Audio may not play.', e);
				}

				// SOUND REDESIGN #3: A single MetalSynth, tuned for a very short, hard, "clink" sound.
				// This is used for all parts of the collision, including the "karan karan" clatter.
				this.clinkSynth = new Tone.PolySynth(Tone.MetalSynth, {
					frequency: 350,
					envelope: { attack: 0.001, decay: 0.1, release: 0.08 },
					harmonicity: 4.1,
					modulationIndex: 22,
					resonance: 3000,
					octaves: 1.2
				}).toDestination();
				if (this.clinkSynth.volume) this.clinkSynth.volume.value = -9;


				this.winSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.45, release: 1.2 } }).toDestination();
				if (this.winSynth.volume) this.winSynth.volume.value = -2;
				
				this.pairSynth = new Tone.PolySynth(Tone.Synth, {
					oscillator: { type: 'sine' },
					envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3 }
				}).toDestination();
				if (this.pairSynth.volume) this.pairSynth.volume.value = -6;

				this.loseSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.003, decay: 0.18, sustain: 0.06, release: 0.22 } }).toDestination();
				if (this.loseSynth.volume) this.loseSynth.volume.value = -10;

				this.foulSynth = new Tone.MonoSynth({ oscillator: { type: 'square' }, filter: { Q: 6, type: 'lowpass', rolloff: -24 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 1 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 1, release: 0.5, baseFrequency: 200, octaves: 2 } }).toDestination();

				this.clickSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.06, sustain: 0.02, release: 0.06 } }).toDestination();
				if (this.clickSynth.volume) this.clickSynth.volume.value = -3;

				this.isInitialized = true;
				console.log("SoundManager initialized.");
			}
			
			/**
			 * DYNAMIC SOUND: Why: 衝撃速度と知覚される音量の関係は線形ではありません。
			 * この関数は指数曲線（Math.pow(norm, 2)）を使用して速度をオーディオレベルにマッピングし、
			 * 小さな衝撃が大きな衝撃よりも大幅に静かになるようにします。これにより、より自然な感覚が得られます。
			 */
			_impactToLevel(velocity, maxVelocity, minLevel = 0.0, maxLevel = 1.0) {
				const norm = Math.min(1.0, Math.max(0.0, velocity / maxVelocity));
				// 2乗を使用することで、低速と高速の衝撃の間に顕著な差が生まれます。
				const level = Math.pow(norm, 2);
				return minLevel + level * (maxLevel - minLevel);
			}

			_pickNote(palette, level) {
				const idx = Math.min(palette.length - 1, Math.floor(level * palette.length));
				return palette[idx];
			}
			
			// SOUND REDESIGN #3: Collision logic now focuses on creating the "karan karan" effect.
			_playCollision(impactVelocity, maxVelocity, notePalette, isBowl) {
				if (!this.isInitialized || !this.clinkSynth) return;
				
				const key = isBowl ? 'bowl' : 'dice';
				if (!this._canPlay(key, isBowl ? 0.08 : 0.07)) return;

				const baseLevel = this._impactToLevel(impactVelocity, maxVelocity, 0.02, 1.0);
				const time = this._now();

				// The "Karan Karan Karan" effect: A series of rapid, slightly randomized clinks.
				const clatterCount = 1 + Math.floor(baseLevel * 4); // 1 to 5 sounds per impact
				for (let i = 0; i < clatterCount; i++) {
					const clatterTime = time + (i * 0.03) + (Math.random() * 0.02);
					const clatterNote = notePalette[Math.floor(Math.random() * notePalette.length)];
					const clatterLevel = baseLevel * (0.5 + Math.random() * 0.5);
					this.clinkSynth.triggerAttackRelease(clatterNote, "16n", clatterTime, clatterLevel);
				}
			}

			playDiceCollision(impactVelocity) {
				const notePalette = ["A4", "C5", "D#5", "F#5", "A5"]; // Higher pitch for dice
				this._playCollision(impactVelocity, this.MAX_IMPACT_VELOCITY_DICE, notePalette, false);
			}

			playBowlCollision(impactVelocity) {
				const notePalette = ['C4', 'E4', 'G4', 'A#4']; // Mid-range pitch for bowl
				this._playCollision(impactVelocity, this.MAX_IMPACT_VELOCITY_BOWL, notePalette, true);
			}

			playWinSound() {
				if (!this.isInitialized || !this.winSynth) return;
				if (!this._canPlay('win', 0.2)) return;
				const t0 = this._now();
				const arp = ['E4', 'G4', 'C5', 'E5'];
				arp.forEach((n, i) => this.winSynth.triggerAttackRelease(n, '8n', t0 + i * 0.06));
			}

			playPairSound() {
				if (!this.isInitialized || !this.pairSynth) return;
				if (!this._canPlay('pair', 0.2)) return;
				const t = this._now();
				this.pairSynth.triggerAttackRelease(['C4', 'E4', 'G4'], '8n', t);
			}

			playLoseSound() {
				if (!this.isInitialized || !this.loseSynth) return;
				if (!this._canPlay('lose', 0.2)) return;
				const t = this._now();
				this.loseSynth.triggerAttackRelease('C3', '16n', t);
				this.loseSynth.triggerAttackRelease('Bb2', '16n', t + 0.08);
			}

			playFoulSound() {
				if (!this.isInitialized || !this.foulSynth) return;
				if (!this._canPlay('foul', 0.5)) return;
				this.foulSynth.triggerAttackRelease('C2', '0.5');
			}

			playClickSound() {
				if (!this.isInitialized || !this.clickSynth) return;
				if (!this._canPlay('click', 0.05)) return;
				this.clickSynth.triggerAttackRelease('C5', '16n', this._now(), 0.5);
			}
		}
		let soundManager;

		/**
		 * @class ParticleEmitter
		 * @description 視覚的なフィードバックのためのシンプルなパーティクル効果を作成します。例えば、サイコロが境界外に出た場合など。
		 */
		class ParticleEmitter {
			constructor(scene, count = 100) {
				this.scene = scene;
				this.particles = [];
				const geometry = new THREE.BufferGeometry();
				// Slightly larger points to improve visibility
				const material = new THREE.PointsMaterial({ color: 0xf0ead6, size: 0.2, transparent: true, opacity: 1, blending: THREE.AdditiveBlending, vertexColors: true });
				this.positions = new Float32Array(count * 3);
				this.colors = new Float32Array(count * 3);
				geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
				geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
				this.points = new THREE.Points(geometry, material);
				// Prevent frustum culling from accidentally hiding the points
				this.points.frustumCulled = false;
				this.points.visible = false;
				this.scene.add(this.points);
				for (let i = 0; i < count; i++) {
					this.particles.push({ position: new THREE.Vector3(), velocity: new THREE.Vector3(), life: 0 });
				}
			}
			// Accept either THREE.Vector3 or objects with x/y/z (e.g., CANNON.Vec3)
			trigger(origin) {
				const particleColor = new THREE.Color(0xf0ead6);
				this.points.visible = true;
				const originVec = (origin && origin.isVector3) ? origin : new THREE.Vector3(origin.x, origin.y, origin.z);
				this.particles.forEach((p, i) => {
					p.position.copy(originVec);
					const speed = 5 + Math.random() * 5;
					p.velocity.set((Math.random() - 0.5) * speed, (Math.random() * 0.5) * speed, (Math.random() - 0.5) * speed);
					p.life = 1.0;
					this.positions[i * 3] = p.position.x;
					this.positions[i * 3 + 1] = p.position.y;
					this.positions[i * 3 + 2] = p.position.z;
					this.colors[i * 3] = particleColor.r;
					this.colors[i * 3 + 1] = particleColor.g;
					this.colors[i * 3 + 2] = particleColor.b;
				});
				this.points.geometry.attributes.position.needsUpdate = true;
				this.points.geometry.attributes.color.needsUpdate = true;
			}
			update(deltaTime) {
				if (!this.points.visible) return;
				let aliveParticles = 0;
				for (let i = 0; i < this.particles.length; i++) {
					const p = this.particles[i];
					if (p.life > 0) {
						p.life -= deltaTime;
						p.velocity.y -= 9.8 * deltaTime;
						p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
						this.positions[i * 3] = p.position.x;
						this.positions[i * 3 + 1] = p.position.y;
						this.positions[i * 3 + 2] = p.position.z;
						aliveParticles++;
					}
				}
				// Safely update opacity based on first particle life if available
				const life0 = (this.particles[0] && typeof this.particles[0].life === 'number') ? this.particles[0].life : 0;
				this.points.material.opacity = Math.max(0, life0);
				this.points.geometry.attributes.position.needsUpdate = true;
				this.points.geometry.attributes.color.needsUpdate = true;
				if (aliveParticles === 0) this.points.visible = false;
			}
		}
		let particleEmitter;

		/**
		 * @function init
		 * @description シーン全体、物理世界、オブジェクト、およびイベントリスナーを初期化します。
		 */
		function init() {
			// --- シーンとレンダラーのセットアップ ---
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x2c3e50); // 暗く中立的な背景色
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 8, 6); // 丼を見下ろす位置
			renderer = new THREE.WebGLRenderer({ antialias: true });
			// OPTIMIZATION: Prevent rendering at excessive resolutions on high-DPI displays.
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true; // リアルさのために影を有効化
			canvasContainer.appendChild(renderer.domElement);
			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true; // カメラ移動をスムーズに
			clock = new THREE.Clock();

			// --- 照明のセットアップ ---
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // ソフトで均等な照明を提供
			scene.add(ambientLight);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // メインの光源（太陽のような）をシミュレート
			directionalLight.position.set(5, 10, 7.5);
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			// --- 物理世界のセットアップ ---
			world = new CANNON.World({ gravity: new CANNON.Vec3(0, -55, 0) }); // よりダイナミックな感じのために重力を強く
			world.allowSleep = true; // 動かないオブジェクトを「スリープ」させてパフォーマンスを向上
			world.sleepSpeedLimit = 0.05;
			world.sleepTimeLimit = 0.5;
			// OPTIMIZATION: Reduced solver iterations for better performance. 20 is a good balance.
			world.solver.iterations = 20;

			// --- マテリアルの定義 ---
			// 異なるオブジェクトの相互作用を制御するために、物理マテリアルを定義（摩擦、反発）。
			const dicePhysicsMaterial = new CANNON.Material('dice');
			const bowlFloorMaterial = new CANNON.Material('bowlFloor');
			const bowlWallMaterial = new CANNON.Material('bowlWall');

			// --- オブジェクトの作成 ---
			createBowl(bowlFloorMaterial, bowlWallMaterial);
			createDice(dicePhysicsMaterial);
			setupContactMaterials(dicePhysicsMaterial, bowlFloorMaterial, bowlWallMaterial);

			particleEmitter = new ParticleEmitter(scene);
			soundManager = new SoundManager();

			// --- イベントリスナーのセットアップ ---
			setupEventListeners();

			// --- シミュレーションを開始 ---
			animate();

			// 開始時にサイコロを丼に配置するための初期ロール。
			setTimeout(() => { rollDice(0, true); }, 100);
		}

		/**
		 * @function setupEventListeners
		 * @description Why: UIとサウンドの初期化に関するイベントリスナーを1か所にまとめることで、
		 * セットアップロジックが整理され、見つけやすくなります。
		 */
		function setupEventListeners() {
			rollButton.disabled = true;

			// Why: サウンドはユーザーの操作後にのみ開始できます。この関数は最初のインタラクションでサウンドを初期化し、
			// その後自身を削除するため、一度しか実行されません。
			const initSoundOnFirstInteraction = async () => {
				await soundManager.init();
				soundManager.playClickSound(); // 最初のクリック音を再生
				// すべての要素からこの初期化リスナーを削除
				canvasContainer.removeEventListener('click', initSoundOnFirstInteraction);
				rollButton.removeEventListener('click', initSoundOnFirstInteraction);
				nudgeButton.removeEventListener('click', initSoundOnFirstInteraction);
				rearrangeButton.removeEventListener('click', initSoundOnFirstInteraction);
			};

			canvasContainer.addEventListener('click', initSoundOnFirstInteraction, { once: true });
			rollButton.addEventListener('click', initSoundOnFirstInteraction, { once: true });
			nudgeButton.addEventListener('click', initSoundOnFirstInteraction, { once: true });
			rearrangeButton.addEventListener('click', initSoundOnFirstInteraction, { once: true });

			// --- 通常のゲームプレイリスナー ---
			rollButton.addEventListener('click', startCharging);
			nudgeButton.addEventListener('click', nudgeDice);
			rearrangeButton.addEventListener('click', resetDiceToStartPosition);
			diceTypeSelector.addEventListener('change', (e) => {
				soundManager.playClickSound();
				diceType = e.target.value;
				updateDiceMaterials();
			});
			canvasContainer.addEventListener('click', decidePower);
			window.addEventListener('resize', onWindowResize);
		}


		/**
		 * @function createBowl
		 * @description 視覚（Three.js）と物理（cannon-es）の丼を作成します。
		 * 視覚表現と物理衝突形状が完全に一致するようにします。
		 */
		function createBowl(bowlFloorMaterial, bowlWallMaterial) {
			const bowlWallThickness = 0.2; // 丼の壁の厚さを定義。
			// TUNNELING FIX: 物理的な壁の厚みを視覚的なものより厚く設定
			const physicsWallThickness = 0.4;
			const bowlMaterial = new THREE.MeshStandardMaterial({ color: 0x6B4F3A, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.7 });
			const bowlGroup = new THREE.Group();

			// --- 視覚的な丼（Three.js） ---
			// 1. 丼の底を作成。
			const bottomGeometry = new THREE.CylinderGeometry(bowlRadius, bowlRadius, 0.2, 64);
			const bottomMesh = new THREE.Mesh(bottomGeometry, bowlMaterial);
			bottomMesh.receiveShadow = true;
			bowlGroup.add(bottomMesh);

			// 2. 厚みのある壁を作成。
			const wallShape = new THREE.Shape();
			wallShape.absarc(0, 0, bowlRadius, 0, Math.PI * 2, false); // 外側の円
			const holePath = new THREE.Path();
			holePath.absarc(0, 0, bowlRadius - bowlWallThickness, 0, Math.PI * 2, true); // 内側の円（穴）
			wallShape.holes.push(holePath);
			const extrudeSettings = { depth: bowlHeight, bevelEnabled: false };
			const wallGeometry = new THREE.ExtrudeGeometry(wallShape, extrudeSettings);
			const wallMesh = new THREE.Mesh(wallGeometry, bowlMaterial);
			wallMesh.rotation.x = -Math.PI / 2; // 直立させるために回転
			wallMesh.receiveShadow = true;
			bowlGroup.add(wallMesh);

			scene.add(bowlGroup);

			// --- 物理的な丼（cannon-es） ---
			const bowlFloorBody = new CANNON.Body({ mass: 0, material: bowlFloorMaterial });
			const bottomShape = new CANNON.Cylinder(bowlRadius, bowlRadius, 0.5, 32);
			bowlFloorBody.addShape(bottomShape, new CANNON.Vec3(0, -0.2, 0));
			world.addBody(bowlFloorBody);

			// OPTIMIZATION: Reduced wall segments from 64 to 32 to lessen physics calculations.
			const bowlWallBody = new CANNON.Body({ mass: 0, material: bowlWallMaterial });
			const wallSegments = 32;
			const segmentAngle = (Math.PI * 2) / wallSegments;
			const segmentWidth = 2 * bowlRadius * Math.tan(segmentAngle / 2);
			// TUNNELING FIX: Use the thicker physics wall for the collision shape.
			const wallShapeCannon = new CANNON.Box(new CANNON.Vec3(segmentWidth / 2, bowlHeight / 2, physicsWallThickness / 2));
			const wallPlacementRadius = bowlRadius - (physicsWallThickness / 2);

			for (let i = 0; i < wallSegments; i++) {
				const angle = i * segmentAngle;
				const position = new CANNON.Vec3(wallPlacementRadius * Math.cos(angle), bowlHeight / 2, wallPlacementRadius * Math.sin(angle));
				const quaternion = new CANNON.Quaternion();
				quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
				bowlWallBody.addShape(wallShapeCannon, position, quaternion);
			}
			world.addBody(bowlWallBody);
		}

		/**
		 * @function createDice
		 * @description 3つのサイコロを視覚的および物理的に作成し、プロパティを設定します。
		 */
		function createDice(dicePhysicsMaterial) {
			const diceGeometry = new THREE.BoxGeometry(diceSize, diceSize, diceSize);
			for (let i = 0; i < 3; i++) {
				// Visual die
				const die = new THREE.Mesh(diceGeometry, []);
				die.castShadow = true;
				scene.add(die);
				dice.push(die);

				// Physical die
				const body = new CANNON.Body({
					mass: 1,
					shape: new CANNON.Box(new CANNON.Vec3(diceSize / 2, diceSize / 2, diceSize / 2)),
					material: dicePhysicsMaterial,
					angularDamping: 0.25, // Simulates air resistance on rotation
					linearDamping: 0.3   // Simulates air resistance on movement
				});
				body.collisionResponse = true;
				// なぜ: CCD（Continuous Collision Detection）を有効化して、高速で移動するサイコロが丼を貫通するのを防ぎます。特にロール開始時。
				body.ccdSpeedThreshold = 0.01;
				body.ccdMotionThreshold = diceSize / 4;

				// Why: 物理エンジンからの衝突イベントをリッスンして、サウンドをトリガーします。
				// これにより、視覚的な出来事と聴覚的なフィードバックが正確に同期します。
				body.addEventListener('collide', (event) => {
					const impactVelocity = event.contact.getImpactVelocityAlongNormal();
					// Why: 非常に小さな衝突（例：静止時の接触）でサウンドが再生されるのを防ぐための閾値。
					if (impactVelocity > 0.5) {
						const otherBodyMaterialName = event.body.material ? event.body.material.name : '';
						if (otherBodyMaterialName === 'dice') {
							soundManager.playDiceCollision(impactVelocity);
						} else if (otherBodyMaterialName === 'bowlFloor' || otherBodyMaterialName === 'bowlWall') {
							soundManager.playBowlCollision(impactVelocity);
						}
					}
				});

				world.addBody(body);
				diceBodies.push(body);
			}
			updateDiceMaterials(); // Apply initial textures
		}

		/**
		 * @function setupContactMaterials
		 * @description 異なるマテリアル間の物理的相互作用プロパティ（摩擦、反発）を定義します。
		 */
		function setupContactMaterials(diceMat, floorMat, wallMat) {
			// How dice interact with the bowl floor
			const diceBowlFloorContact = new CANNON.ContactMaterial(floorMat, diceMat, { friction: 0.25, restitution: 0.5 });
			world.addContactMaterial(diceBowlFloorContact);
			// How dice interact with the bowl wall
			const diceBowlWallContact = new CANNON.ContactMaterial(wallMat, diceMat, { friction: 0.1, restitution: 0.6 });
			world.addContactMaterial(diceBowlWallContact);
			// How dice interact with each other
			const diceDiceContactMaterial = new CANNON.ContactMaterial(diceMat, diceMat, { friction: 0.15, restitution: 0.4 });
			world.addContactMaterial(diceDiceContactMaterial);
		}

		/**
		 * @function updateDiceMaterials
		 * @description 選択されたサイコロの種類に基づいて、サイコロに正しい面テクスチャを適用します。
		 */
		function updateDiceMaterials() {
			let faceSet;
			switch (diceType) {
				case 'shigoro': faceSet = [4, 4, 5, 5, 6, 6]; break; // Special dice for aiming for "Shigoro"
				case 'pinzoro': faceSet = [1, 1, 1, 1, 1, 1]; break; // Special dice for aiming for "Pinzoro"
				default: faceSet = [1, 6, 2, 5, 3, 4]; break; // Standard dice layout
			}
			dice.forEach(die => {
				die.material.forEach(m => m.dispose()); // Dispose old materials to free up memory
				die.material = faceSet.map(val => new THREE.MeshStandardMaterial({ map: createDiceTexture(val) }));
			});
		}

		/**
		 * @function createDiceTexture
		 * @description サイコロの1つの面のキャンバステクスチャを生成します。
		 */
		function createDiceTexture(value) {
			const canvas = document.createElement('canvas');
			canvas.width = 128; canvas.height = 128;
			const context = canvas.getContext('2d');
			context.fillStyle = '#f0ead6'; // Off-white background
			context.fillRect(0, 0, 128, 128);
			const dotRadius = 12;
			// 標準的なサイコロの面のドット位置 1-6
			const positions = { 1: [[0.5, 0.5]], 2: [[0.25, 0.25], [0.75, 0.75]], 3: [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]], 4: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]], 5: [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]], 6: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.5], [0.75, 0.5], [0.25, 0.75], [0.75, 0.75]], };
			context.fillStyle = (value === 1) ? '#c0392b' : '#2c3e50'; // Red for '1', black for others
			if (positions[value]) { positions[value].forEach(pos => { context.beginPath(); context.arc(pos[0] * 128, pos[1] * 128, dotRadius, 0, Math.PI * 2); context.fill(); }); }
			return new THREE.CanvasTexture(canvas);
		}

		/**
		 * @function resetDiceToStartPosition
		 * @description 新しいロールの準備として、サイコロを初期位置にリセットします。
		 */
		function resetDiceToStartPosition() {
			soundManager.playClickSound();
			const startPositions = [new CANNON.Vec3(0, 4.5, 0.3), new CANNON.Vec3(-0.3, 4.7, -0.2), new CANNON.Vec3(0.3, 4.9, -0.2)];
			diceBodies.forEach((body, i) => {
				body.velocity.set(0, 0, 0); body.angularVelocity.set(0, 0, 0);
				body.position.copy(startPositions[i]);
				// Apply a random rotation to each die
				const randomAxis = new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit();
				const randomAngle = Math.random() * Math.PI * 2;
				body.quaternion.setFromAxisAngle(randomAxis, randomAngle);
				// Sync visual model to physical body
				dice[i].position.copy(body.position);
				dice[i].quaternion.copy(body.quaternion);
				dice[i].visible = true;
			});
		}

		/**
		 * @function startCharging
		 * @description ユーザーがロールボタンをクリックしたときに、パワーチャージシーケンスを開始します。
		 */
		function startCharging() {
			if (gameState !== 'ready') return;
			soundManager.playClickSound();
			resetDiceToStartPosition();
			rearrangeButton.style.display = 'block';
			diceTypeSelector.disabled = true;
			gameState = 'charging';
			resultTitle.textContent = '…';
			resultDescription.textContent = '画面をクリックしてパワーを決定';
			rollButton.style.display = 'none';
			powerMeterContainer.style.display = 'block';
			power = 0; powerDirection = 1;
			powerAnimationId = requestAnimationFrame(updatePowerMeter);
		}

		/**
		 * @function updatePowerMeter
		 * @description パワーメーターバーをアニメーション化します。
		 */
		function updatePowerMeter() {
			power += powerDirection * 2.0;
			if (power >= 100) { power = 100; powerDirection = -1; }
			else if (power <= 0) { power = 0; powerDirection = 1; }
			powerMeterBar.style.width = `${power}%`;
			if (gameState === 'charging') powerAnimationId = requestAnimationFrame(updatePowerMeter);
		}

		/**
		 * @function decidePower
		 * @description パワーメーターを停止し、選択されたパワーでサイコロのロールを開始します。
		 */
		function decidePower() {
			if (gameState !== 'charging') return;
			soundManager.playClickSound();
			cancelAnimationFrame(powerAnimationId);
			rearrangeButton.style.display = 'none';
			rollDice(power);
		}

		/**
		 * @function rollDice
		 * @description 指定されたパワーでサイコロを投げ、力とトルクを適用します。
		 */
		function rollDice(throwPower, isInitialSetup = false) {
			gameState = isInitialSetup ? 'initializing' : 'rolling';
			if (!isInitialSetup) {
				rollStartTime = performance.now();
			}
			nudgeButton.style.display = 'none';
			shonbenTimers.fill(0);

			// --- 投擲力の計算 ---
			const minPower = 12;
			const maxPower = 36;
			// 低いパワーの投擲をより敏感にするために、パワーカーブを使用。
			const powerRatio = Math.pow(throwPower / 100, 1.5);
			const force = minPower + (maxPower - minPower) * powerRatio;

			if (isInitialSetup) {
				// 初期セットアップの場合、サイコロを優しく落とすだけ。
				const startPositions = [new CANNON.Vec3(0, 4, 0.6), new CANNON.Vec3(-0.6, 4.5, -0.3), new CANNON.Vec3(0.6, 5, -0.3)];
				diceBodies.forEach((body, i) => {
					dice[i].visible = true;
					body.wakeUp(); body.position.copy(startPositions[i]);
					const randomAxis = new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit();
					body.quaternion.setFromAxisAngle(randomAxis, Math.random() * Math.PI * 2);
					body.velocity.set(0, 0, 0); body.angularVelocity.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3);
				});
			} else {
				// プレイヤー制御のロールの場合、計算された力を適用。
				diceBodies.forEach((body, i) => {
					dice[i].visible = true;
					body.wakeUp();
					body.position.copy(dice[i].position);
					body.quaternion.copy(dice[i].quaternion);

					// なぜ: パワーに基づいて投擲角度を調整。
					// 低いパワーはほぼ垂直なドロップ、高いパワーはより水平な投擲。
					// これにより、弱い投擲がすぐに丼から出るのを防ぎます。
					let velDir;
					if (powerRatio < 0.01) {
						// 非常に弱い投擲は真下に落ちる。
						velDir = new CANNON.Vec3(0, -1, 0);
					} else {
						// 垂直成分は決して上向きにならないように調整。
						const yMax = -(1 - powerRatio);
						const yMin = -1.0;
						const yComponent = yMin + (Math.random() * (yMax - yMin));

						// 水平成分はパワーに比例。
						const xzMagnitude = powerRatio * 1.5;

						velDir = new CANNON.Vec3(
							(Math.random() - 0.5) * 2 * xzMagnitude,
							yComponent,
							(Math.random() - 0.5) * 2 * xzMagnitude
						);
					}

					// ゼロベクトルの安全チェック。
					if (velDir.lengthSquared() < 1e-6) {
						velDir.set(0, -1, 0);
					}

					// 最終的な速度とランダムなスピンを適用。
					const velocityDirection = velDir.unit();
					body.velocity.copy(velocityDirection.scale(force));
					// More natural spin: pick an axis roughly perpendicular to the
					// throw direction and set angular velocity along that axis.
					// This reduces unrealistic spins like all-around random huge values.
					// Configure reasonable min/max spin (radians/sec).
					const minSpin = 8;   // gentle tumble
					const maxSpin = 80;  // vigorous tumble for full power
					const spinMag = minSpin + (maxSpin - minPower) * Math.min(1, Math.max(0, powerRatio));

					// Candidate random vector
					const rc = new CANNON.Vec3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
					// cross product velocityDirection x rc to get roughly perpendicular axis
					const axis = new CANNON.Vec3(
						velocityDirection.y * rc.z - velocityDirection.z * rc.y,
						velocityDirection.z * rc.x - velocityDirection.x * rc.z,
						velocityDirection.x * rc.y - velocityDirection.y * rc.x
					);
					// fallback if cross produced near-zero vector
					let spinAxis = axis;
					if (spinAxis.lengthSquared() < 1e-6) spinAxis = new CANNON.Vec3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
					spinAxis = spinAxis.unit();

					// base spin along axis, plus a small random tilt to avoid perfect alignment
					const tiltFactor = 0.25;
					const spinVec = new CANNON.Vec3(
						spinAxis.x * spinMag + (Math.random() - 0.5) * spinMag * tiltFactor,
						spinAxis.y * spinMag + (Math.random() - 0.5) * spinMag * tiltFactor,
						spinAxis.z * spinMag + (Math.random() - 0.5) * spinMag * tiltFactor
					);

					// clamp extreme magnitudes
					const maxAllowed = maxSpin * 1.2;
					if (spinVec.length() > maxAllowed) spinVec.scale(maxAllowed / spinVec.length(), spinVec);

					body.angularVelocity.copy(spinVec);
				});
			}
		}

		/**
		 * @function nudgeDice
		 * @description サイコロがスタックした場合、各サイコロに小さなランダムなインパルスを適用します。
		 */
		function nudgeDice() {
			if (gameState !== 'rolling') return;
			soundManager.playClickSound();
			const nudgeForce = 5;
			diceBodies.forEach(body => {
				body.wakeUp();
				const force = new CANNON.Vec3((Math.random() - 0.5) * nudgeForce, Math.random() * nudgeForce, (Math.random() - 0.5) * nudgeForce);
				const point = new CANNON.Vec3((Math.random() - 0.5) * diceSize * 0.5, (Math.random() - 0.5) * diceSize * 0.5, (Math.random() - 0.5) * diceSize * 0.5);
				body.applyImpulse(force, point);
			});
			nudgeButton.style.display = 'none';
		}

		/**
		 * @function getDiceFace
		 * @description サイコロのどの面が上を向いているかを決定します。
		 */
		function getDiceFace(body) {
			const up = new CANNON.Vec3(0, 1, 0); // World's 'up' direction
			let maxDot = -1, topFace = -1;
			// サイコロの各面のローカル方向を表すベクトル
			const faceVectors = [new CANNON.Vec3(1, 0, 0), new CANNON.Vec3(-1, 0, 0), new CANNON.Vec3(0, 1, 0), new CANNON.Vec3(0, -1, 0), new CANNON.Vec3(0, 0, 1), new CANNON.Vec3(0, 0, -1)];
			let faceValues;
			// Map local face vectors to their corresponding number values
			switch (diceType) {
				case 'shigoro': faceValues = [4, 4, 5, 5, 6, 6]; break;
				case 'pinzoro': faceValues = [1, 1, 1, 1, 1, 1]; break;
				default: faceValues = [1, 6, 2, 5, 3, 4]; break; // Standard mapping
			}
			// 世界の「上」方向に最も近い面ベクトルを見つける。
			for (let i = 0; i < faceVectors.length; i++) {
				const worldVector = body.quaternion.vmult(faceVectors[i]);
				const dot = worldVector.dot(up);
				if (dot > maxDot) { maxDot = dot; topFace = faceValues[i]; }
			}
			return topFace;
		}

		/**
		 * @function finishRoll
		 * @description 最終結果をUIに更新し、ゲーム状態を'ready'にリセットします。
		 */
		function finishRoll(result, desc) {
			resultTitle.textContent = result;
			resultDescription.textContent = desc;
			nudgeButton.style.display = 'none';
			rearrangeButton.style.display = 'none';
			diceTypeSelector.disabled = false;
			gameState = 'ready';
			rollButton.style.display = 'block';
			rollButton.disabled = false;
		}

		/**
		 * @function areAllDiceStable
		 * @description サイコロが平らな面に落ち着いているかをチェックします。
		 * これは、物理ボディがスリープしたかどうかだけを待つよりも堅牢なチェックです。
		 */
		function areAllDiceStable() {
			const STABILITY_THRESHOLD = 0.99; // How flat the face must be (dot product close to 1)
			for (const body of diceBodies) {
				if (!dice[diceBodies.indexOf(body)].visible) continue;
				let isStable = false;
				const localAxes = [new CANNON.Vec3(1, 0, 0), new CANNON.Vec3(0, 1, 0), new CANNON.Vec3(0, 0, 1)];
				for (const axis of localAxes) {
					const worldAxis = body.quaternion.vmult(axis);
					const dotProduct = Math.abs(worldAxis.dot(new CANNON.Vec3(0, 1, 0)));
					if (dotProduct > STABILITY_THRESHOLD) { isStable = true; break; }
				}
				if (!isStable) return false; // If any die is not stable, return false
			}
			return true; // All visible dice are stable
		}

		/**
		 * @function checkAndDisplayResult
		 * @description サイコロの値をチェックし、対応するチンチロリンの結果を表示します。
		 */
		function checkAndDisplayResult() {
			rollButton.disabled = true;
			const visibleDiceBodies = diceBodies.filter((body, i) => dice[i].visible);

			// Check for "Shonben" (foul)
			if (visibleDiceBodies.length < 3) {
				soundManager.playFoulSound();
				finishRoll("ションベン！", "サイコロが丼から出てしまいました。");
				return;
			}

			// --- 役の決定 ---
			const values = visibleDiceBodies.map(getDiceFace).sort((a, b) => a - b);
			let title = '', description = `出目: ${values.join(', ')}`;
			const counts = {}; values.forEach(v => { counts[v] = (counts[v] || 0) + 1; });

			let hasWon = false;
			if (Object.values(counts).includes(3)) {
				// Triple
				title = (values[0] === 1) ? "ピンゾロ" : "アラシ";
				hasWon = true;
			} else if (Object.values(counts).includes(2)) {
				// Pair
				const singleValue = Object.keys(counts).find(k => counts[k] === 1);
				title = `${['', '一', '二', '三', '四', '五', '六'][singleValue]}の目`;
			} else {
				// ペアやトリプルなし
				switch (diceType) {
					case 'shigoro':
						if (values.join('') === '456') { title = "シゴロ"; hasWon = true; }
						else title = "目なし";
						break;
					default:
						if (values.join('') === '456') { title = "シゴロ"; hasWon = true; }
						else if (values.join('') === '123') title = "ヒフミ";
						else title = "目なし";
						break;
				}
			}
			
			// --- Sound Triggering Logic ---
			// Why: 役の結果に基づいて適切なサウンドを再生するための、明確で分離されたロジック。
			// これにより、どの結果がどのサウンドをトリガーするかが分かりやすくなります。
			if (title === "ヒフミ") {
				soundManager.playFoulSound(); // カイト様のご指示通り、「ションベン」と同じ音を再生
			} else if (hasWon) {
				// ピンゾロ, アラシ, シゴロ
				soundManager.playWinSound();
			} else if (title === "目なし") {
				soundManager.playLoseSound();
			} else if (title.includes("の目")) {
				// FIXED: Call the dedicated sound for pairs.
				soundManager.playPairSound();
			}
			// 「ションベン」の音は、この関数の冒頭で既に再生されています。

			finishRoll(title, description);
		}

		let lastCheckTime = 0;
		/**
		 * @function animate
		 * @description メインのアニメーションループ、各フレームごとに呼び出されます。
		 */
		function animate() {
			requestAnimationFrame(animate);
			const deltaTime = clock.getDelta();

			// ゲームが動的な状態にある場合のみ、物理世界をステップ。
			if (gameState === 'rolling' || gameState === 'initializing') {
				// TUNNELING FIX: maxSubstepsを増やすことで、フレームドロップ時の物理的な精度を向上させます。
				world.step(1 / 60, deltaTime, 20);

				// 視覚オブジェクトを物理カウンターパートと同期。
				for (let i = 0; i < dice.length; i++) {
					dice[i].position.copy(diceBodies[i].position);
					dice[i].quaternion.copy(diceBodies[i].quaternion);
				}
			}

			particleEmitter.update(deltaTime);
			controls.update();
			renderer.render(scene, camera);

			// パワーチャージ中にサイコロを軌道アニメーション。
			if (gameState === 'charging') {
				const elapsedTime = clock.getElapsedTime();
				const orbitRadius = 0.4;
				const orbitSpeed = 60.0;
				const rotationSpeed = 40.0;
				dice.forEach((die, i) => {
					const angle = elapsedTime * orbitSpeed + (i * 2 * Math.PI / 3);
					const bodyPos = diceBodies[i].position;
					die.position.x = bodyPos.x + Math.cos(angle) * orbitRadius;
					die.position.z = bodyPos.z + Math.sin(angle) * orbitRadius;
					die.position.y = bodyPos.y + Math.sin(elapsedTime * (orbitSpeed * 1.5) + i) * 0.1;

					const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 1, 1).normalize(), (rotationSpeed + i * 0.5) * deltaTime);
					die.quaternion.premultiply(q);
				});
			}


			// --- State Checking Logic ---
			if (gameState === 'rolling' || gameState === 'initializing') {
				const now = performance.now();

				// Check for "Shonben" (foul) condition for each die.
				for (let i = 0; i < diceBodies.length; i++) {
					const body = diceBodies[i];
					if (!dice[i].visible) continue;
					const horizontalDistSq = body.position.x * body.position.x + body.position.z * body.position.z;
					const isOutside = horizontalDistSq > bowlRadius * bowlRadius;
					const isBelow = body.position.y < -0.5;
					if (isOutside && isBelow) {
						if (shonbenTimers[i] === 0) shonbenTimers[i] = now;
						else if (now - shonbenTimers[i] > SHONBEN_GRACE_PERIOD_MS) {
							dice[i].visible = false;
							body.sleep();
							body.position.set(0, -100 - i, 0); // Move it far away
							particleEmitter.trigger(dice[i].position);
						}
					} else { shonbenTimers[i] = 0; }
				}

				// Check if all dice have stopped moving.
				const isStill = diceBodies.every(body => body.sleepState === CANNON.Body.SLEEPING || !dice[diceBodies.indexOf(body)].visible);

				if (isStill) {
					// If they have stopped, also check if they are stable on a face.
					if (areAllDiceStable()) {
						if (gameState === 'initializing') {
							// If it was the initial setup, transition to ready state.
							gameState = 'ready';
							rollButton.disabled = false;
						} else if (gameState === 'rolling') {
							// If it was a roll, wait a brief moment before checking the result to let the user see the final state.
							if (lastCheckTime === 0) lastCheckTime = now;
							else if (now - lastCheckTime > 200) {
								lastCheckTime = 0; gameState = 'checking';
								checkAndDisplayResult();
							}
						}
					} else { lastCheckTime = 0; }
				} else { lastCheckTime = 0; }

				// Why: カイト様のご指摘に基づき、「揺らす」ボタンの表示条件を、より本質的で確実なものに修正しました。
				// (Why: Based on Kaito-sama's feedback, the display condition for the "Nudge" button has been corrected to be more fundamental and reliable.)
				if (gameState === 'rolling') {
					const elapsedTime = now - rollStartTime;
					if (elapsedTime > STUCK_THRESHOLD_MS) {
						nudgeButton.style.display = 'block';
					}
				} else {
					nudgeButton.style.display = 'none';
				}
			}
		}

		/**
		 * @function onWindowResize
		 * @description ウィンドウリサイズイベントを処理し、ビューポートとカメラのアスペクト比を正しく保ちます。
		 */
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			// OPTIMIZATION: Ensure pixel ratio is also updated on resize.
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		// Let's roll!
		init();
	</script>
</body>

</html>

