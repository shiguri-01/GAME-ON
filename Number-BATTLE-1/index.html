<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ナンバーバトル</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Mochiy+Pop+One', sans-serif;
			touch-action: manipulation;
		}

		.hand-container {
			position: relative;
			width: 120px;
			height: 120px;
			display: flex;
			align-items: center;
			justify-content: center;
			border: 4px solid transparent;
			border-radius: 1rem;
			transition: all 0.2s ease-in-out;
			cursor: pointer;
		}

		.hand-container.dead {
			background-color: #374151;
			/* gray-700 */
			cursor: not-allowed;
			opacity: 0.6;
		}

		.hand-container.selectable {
			border-color: #f59e0b;
			/* amber-500 */
			transform: scale(1.05);
		}

		.hand-container.selected {
			border-color: #22c55e;
			/* green-500 */
			transform: scale(1.1);
			box-shadow: 0 0 20px #22c55e;
		}

		.hand-container.targetable {
			border-color: #ef4444;
			/* red-500 */
			transform: scale(1.05);
		}

		.finger-count {
			font-size: 3rem;
			font-weight: bold;
			-webkit-user-select: none;
			user-select: none;
		}

		.split-button {
			transition: all 0.15s ease-out;
		}

		.split-button:hover {
			transform: translateY(-2px) scale(1.05);
		}

		/* Split modal */
		.split-modal-backdrop {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.6);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 50;
		}

		.split-modal {
			background: #111827;
			/* gray-900 */
			padding: 16px;
			border-radius: 12px;
			width: 320px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
		}

		.split-option {
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: 12px;
			margin-bottom: 8px;
		}

		.split-option button {
			flex: 1;
		}

		.attack-animation {
			position: absolute;
			width: 100%;
			height: 100%;
			border-radius: 0.75rem;
			animation: attack-flash 0.2s ease-out;
			pointer-events: none;
		}

		@keyframes attack-flash {
			0% {
				background-color: rgba(255, 255, 0, 0);
				transform: scale(1);
			}

			50% {
				background-color: rgba(255, 255, 0, 0.7);
				transform: scale(1.2);
			}

			100% {
				background-color: rgba(255, 255, 0, 0);
				transform: scale(1);
			}
		}

		/* Modal Styles */
		.modal {
			display: flex;
		}

		.modal.hidden {
			display: none;
		}
	</style>
</head>

<body class="bg-gray-800 text-white flex items-center justify-center min-h-screen">
	<!-- スタート画面 -->
	<div id="start-screen" class="w-full max-w-lg mx-auto p-4 text-center">
		<h1 class="text-5xl font-bold mb-8" style="font-family: 'Mochiy Pop One', sans-serif;">ナンバーバトル</h1>
		<div class="mb-8">
			<h2 class="text-2xl mb-4">CPUの強さをえらんでね</h2>
			<div id="start-cpu-mode-selector" class="flex justify-center gap-4">
				<button data-mode="normal"
					class="cpu-mode-btn-start text-lg bg-gray-700 hover:bg-gray-600 text-white px-6 py-3 rounded-lg">普通</button>
				<button data-mode="strong"
					class="cpu-mode-btn-start text-lg bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg">最強</button>
			</div>
		</div>
		<button id="start-button"
			class="bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-8 rounded-lg text-3xl">ゲーム開始！</button>
	</div>

	<!-- ゲーム画面 (最初は非表示) -->
	<div id="game-container" class="hidden w-full max-w-lg mx-auto p-4 text-center">

		<!-- CPUエリア -->
		<div id="cpu-area" class="bg-red-900/50 p-4 rounded-lg mb-4">
			<h2 class="text-2xl mb-2">CPU (<span id="cpu-mode-display"></span>)</h2>
			<div id="cpu-hands" class="flex justify-center items-center space-x-4">
				<div id="cpu-hand-left" class="hand-container" data-owner="cpu" data-index="0">
					<span class="finger-count">1</span>
				</div>
				<div id="cpu-hand-right" class="hand-container" data-owner="cpu" data-index="1">
					<span class="finger-count">1</span>
				</div>
			</div>
		</div>

		<!-- ターン/情報エリア -->
		<div id="info-area" class="h-16 flex items-center justify-center gap-3">
			<p id="turn-indicator" class="text-3xl text-yellow-300">あなたのターン</p>
		</div>

		<!-- プレイヤーエリア -->
		<div id="player-area" class="bg-cyan-900/50 p-4 rounded-lg mt-4">
			<div id="player-hands" class="flex justify-center items-center space-x-4">
				<div id="player-hand-left" class="hand-container" data-owner="player" data-index="0">
					<span class="finger-count">1</span>
				</div>
				<div id="player-hand-right" class="hand-container" data-owner="player" data-index="1">
					<span class="finger-count">1</span>
				</div>
			</div>
			<h2 class="text-2xl mt-2">あなた</h2>
			<div id="player-actions" class="h-12 mt-2 flex justify-center items-center space-x-4">
				<!-- Split buttons will be generated here -->
			</div>
		</div>
		<!-- Split modal (hidden by default) -->
		<div id="split-modal-backdrop" class="split-modal-backdrop hidden">
			<div class="split-modal">
				<h3 class="text-xl mb-3">分割オプション</h3>
				<div id="split-options">
					<!-- options inserted here -->
				</div>
				<div class="mt-3 text-right">
					<button id="split-cancel"
						class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">キャンセル</button>
				</div>
			</div>
		</div>

		<!-- ゲームオーバー画面 -->
		<div id="game-over-screen"
			class="hidden fixed inset-0 bg-black/70 flex flex-col items-center justify-center z-10">
			<h2 id="game-over-text" class="text-5xl text-yellow-300 mb-8"></h2>
			<div class="mb-6">
				<h3 class="text-xl mb-3">次のゲームの強さ</h3>
				<div id="game-over-cpu-mode-selector" class="flex justify-center gap-4">
					<button data-mode="normal"
						class="cpu-mode-btn-game-over text-lg bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">普通</button>
					<button data-mode="strong"
						class="cpu-mode-btn-game-over text-lg bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">最強</button>
				</div>
			</div>
			<button id="restart-button"
				class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg text-2xl">もう一度遊ぶ</button>
		</div>

	</div>

	<script>
		// --- DOM Elements ---
		const gameContainer = document.getElementById('game-container');
		const turnIndicator = document.getElementById('turn-indicator');
		const playerActions = document.getElementById('player-actions');
		const gameOverScreen = document.getElementById('game-over-screen');
		const gameOverText = document.getElementById('game-over-text');
		const restartButton = document.getElementById('restart-button');
		const cpuModeToggle = document.getElementById('cpu-mode-toggle');
		const startScreen = document.getElementById('start-screen');
		const startButton = document.getElementById('start-button');
		const cpuModeDisplay = document.getElementById('cpu-mode-display');
		const handElements = {
			player: [document.getElementById('player-hand-left'), document.getElementById('player-hand-right')],
			cpu: [document.getElementById('cpu-hand-left'), document.getElementById('cpu-hand-right')]
		};

		// --- Game State ---
		let hands = { player: [1, 1], cpu: [1, 1] };
		let turn = 'player';
		let gameState = 'playing'; // 'playing', 'cpu_thinking', 'gameover'
		let selectedHand = null; // { owner: 'player', index: 0 }
		let turnCount = 0; // To track the number of turns
		let CPU_MODE = 'strong'; // 'normal' | 'strong'

		cpuModeToggle?.addEventListener('click', () => {
			CPU_MODE = CPU_MODE === 'normal' ? 'strong' : 'normal';
			cpuModeToggle.textContent = `CPU: ${CPU_MODE === 'strong' ? '最強' : '普通'}`;
		});

		// --- Game Logic ---

		// Helper to sync CPU mode buttons' visuals on start and game-over screens
		function syncCpuModeButtons() {
			// Start screen buttons
			document.querySelectorAll('.cpu-mode-btn-start').forEach(b => {
				b.classList.remove('bg-blue-600', 'bg-gray-700');
				if (b.dataset.mode === CPU_MODE) {
					b.classList.add('bg-blue-600');
				} else {
					b.classList.add('bg-gray-700');
				}
			});

			// Game-over buttons
			document.querySelectorAll('.cpu-mode-btn-game-over').forEach(b => {
				b.classList.remove('bg-blue-600', 'bg-gray-700');
				if (b.dataset.mode === CPU_MODE) {
					b.classList.add('bg-blue-600');
				} else {
					b.classList.add('bg-gray-700');
				}
			});
			// reflect in header display
			if (cpuModeDisplay) cpuModeDisplay.textContent = CPU_MODE === 'strong' ? '最強' : '普通';
		}

		function updateUI() {
			// Update CPU mode display
			cpuModeDisplay.textContent = CPU_MODE === 'strong' ? '最強' : '普通';

			// Update finger counts and dead status
			['player', 'cpu'].forEach(owner => {
				hands[owner].forEach((count, index) => {
					const handEl = handElements[owner][index];
					const isDead = (count === 5 || count === 0);
					handEl.querySelector('.finger-count').textContent = isDead ? 'X' : count;
					handEl.classList.toggle('dead', isDead);
				});
			});

			// Update highlights
			document.querySelectorAll('.hand-container').forEach(el => {
				el.classList.remove('selectable', 'selected', 'targetable');
				if (gameState === 'gameover' || el.classList.contains('dead') || hands[el.dataset.owner][el.dataset.index] === 0) return;

				const owner = el.dataset.owner;
				const index = parseInt(el.dataset.index);

				if (turn === 'player' && owner === 'player') {
					el.classList.add('selectable');
				}
				if (selectedHand && selectedHand.owner === owner && selectedHand.index === index) {
					el.classList.add('selected');
				}
				if (selectedHand && turn === 'player' && owner === 'cpu') {
					el.classList.add('targetable');
				}
			});

			// Update turn indicator
			if (turn === 'player' && gameState === 'playing') {
				if (selectedHand) {
					turnIndicator.textContent = "相手の手をタップ！";
				} else {
					turnIndicator.textContent = "自分の手をえらんで";
				}
			} else if (turn === 'cpu') {
				turnIndicator.textContent = "CPUのターン...";
			}

			// Update split buttons
			playerActions.innerHTML = '';
			// Show a single split button based on the sum of active (not 0/5) player hands
			const activeIndices = [0, 1].filter(i => hands.player[i] !== 5 && hands.player[i] !== 0);
			const playerSumActive = activeIndices.reduce((s, i) => s + hands.player[i], 0);
			if (playerSumActive >= 2 && gameState === 'playing' && turn === 'player') {
				const splitButton = document.createElement('button');
				splitButton.textContent = `分割: 合計 ${playerSumActive}`;
				splitButton.className = 'split-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg';
				splitButton.onclick = () => openSplitModalSum();
				playerActions.appendChild(splitButton);
			}
		}

		function handleHandClick(e) {
			if (gameState !== 'playing') return;
			const target = e.target.closest('.hand-container');
			if (!target || target.classList.contains('dead') || hands[target.dataset.owner][target.dataset.index] === 0) return;

			const owner = target.dataset.owner;
			const index = parseInt(target.dataset.index);

			if (turn === 'player') {
				if (owner === 'player') {
					// toggle selection when clicking the same hand
					if (selectedHand && selectedHand.owner === owner && selectedHand.index === index) {
						selectedHand = null;
					} else {
						selectedHand = { owner, index };
					}
					// reflect immediately
					updateUI();
				} else if (owner === 'cpu' && selectedHand) {
					performAttack(selectedHand, { owner, index });
				}
			}
		}

		function performAttack(source, target) {
			const sourceValue = hands[source.owner][source.index];
			const targetValue = hands[target.owner][target.index];

			// Sum and normalize to 1..5 using modulo-like wrapping.
			// Example: 3 + 4 = 7 -> ((7 - 1) % 5) + 1 = 2
			let newValue = ((sourceValue + targetValue - 1) % 5) + 1;
			hands[target.owner][target.index] = newValue;

			// Animation
			const targetEl = handElements[target.owner][target.index];
			const flash = document.createElement('div');
			flash.className = 'attack-animation';
			targetEl.appendChild(flash);
			setTimeout(() => flash.remove(), 200);

			selectedHand = null;

			if (checkWin()) {
				endGame();
			} else {
				switchTurn();
			}
			updateUI();
		}

		function handleSplit(index) {
			if (turn !== 'player' || gameState !== 'playing') return;
			const splitValue = hands.player[index] / 2;
			hands.player = [splitValue, splitValue];
			switchTurn();
			updateUI();
		}

		function switchTurn() {
			turnCount++; // Increment turn counter
			turn = turn === 'player' ? 'cpu' : 'player';
			if (turn === 'cpu') {
				gameState = 'cpu_thinking';
				setTimeout(cpuTurn, 500);
			} else {
				gameState = 'playing';
			}
		}

		function checkWin() {
			const isDead = (v) => v === 5 || v === 0;
			const playerLost = hands.player.every(isDead);
			const cpuLost = hands.cpu.every(isDead);
			if (playerLost || cpuLost) {
				gameState = 'gameover';
				gameOverText.textContent = playerLost ? "あなたの負け..." : "あなたの勝利！";
				return true;
			}
			return false;
		}

		function endGame() {
			gameOverScreen.classList.remove('hidden');
		}

		// --- CPU AI ---
		// ---- CPU Decision Helpers ----
		const wrapTo1to5 = (v) => ((v - 1) % 5) + 1; // assumes v>=1
		function enumerateAttacks(owner, opp) {
			const moves = [];
			for (let i of [0, 1]) {
				if (hands[owner][i] === 5 || hands[owner][i] === 0) continue;
				for (let j of [0, 1]) {
					if (hands[opp][j] === 5 || hands[opp][j] === 0) continue;
					const s = hands[owner][i];
					const t = hands[opp][j];
					const newT = wrapTo1to5(s + t);
					moves.push({ type: 'attack', src: i, dst: j, newT });
				}
			}
			return moves;
		}

		function sumActive(owner) {
			return [0, 1]
				.filter(i => hands[owner][i] !== 5 && hands[owner][i] !== 0)
				.reduce((a, i) => a + hands[owner][i], 0);
		}

		function enumerateSplitsForOwner(owner) {
			const sum = sumActive(owner);
			if (sum < 2) return [];
			const patterns = new Set();
			const isDead = v => v === 0 || v === 5;

			// Generate all possible splits
			for (let i = 0; i <= sum; i++) {
				const j = sum - i;
				if (i <= 5 && j <= 5) {
					patterns.add(`${i},${j}`);
				}
			}

			// Normalize 5 -> 0 for comparison so dead hands are treated uniformly
			const curL = hands[owner][0] === 5 ? 0 : hands[owner][0];
			const curR = hands[owner][1] === 5 ? 0 : hands[owner][1];
			const currentDistribution = `${curL},${curR}`;
			const swappedDistribution = `${curR},${curL}`;

			return Array.from(patterns)
				// Don't suggest the current distribution or just a swap
				// Filter out distributions that are numerically identical to current (including swapped)
				.filter(p => p !== currentDistribution && p !== swappedDistribution)
				.map(s => {
					const [l, r] = s.split(',').map(Number);
					// Don't suggest a move that leads to immediate loss
					if (isDead(l) && isDead(r)) {
						return null;
					}
					return { type: 'split', left: l, right: r };
				})
				.filter(move => move !== null); // Filter out nulls
		}

		function isTerminalEval() {
			const dead = (h) => h === 0 || h === 5;
			const playerLost = hands.player.every(dead);
			const cpuLost = hands.cpu.every(dead);
			if (cpuLost) return -1e6; // worst
			if (playerLost) return 1e6; // best
			return null;
		}

		function heuristicEval() {
			const isDead = (v) => v === 5 || v === 0;
			const enemyAlive = hands.player.filter(h => !isDead(h));
			const selfAlive = hands.cpu.filter(h => !isDead(h));

			// Terminal states are handled by isTerminalEval, but as a fallback:
			if (enemyAlive.length === 0) return 1e6; // CPU wins
			if (selfAlive.length === 0) return -1e6; // CPU loses

			let score = 0;

			// Prioritize reducing the number of opponent's hands. This is a huge advantage.
			score += (2 - enemyAlive.length) * 1000;

			// Penalize losing own hands.
			score -= (2 - selfAlive.length) * 1000;

			// Evaluate hand positions for finer-grained decisions.
			let enemyHandScore = 0;
			enemyAlive.forEach(hand => {
				// Pushing enemy hands towards 5 is good. A hand of 4 is a prime target.
				if (hand === 4) {
					enemyHandScore += 150;
				} else {
					enemyHandScore += hand * 10;
				}
			});
			score += enemyHandScore;

			let selfHandScore = 0;
			selfAlive.forEach(hand => {
				// Having own hands close to 5 is risky. A hand of 4 is very dangerous.
				if (hand === 4) {
					selfHandScore += 120;
				} else {
					selfHandScore += hand * 5;
				}
			});
			score -= selfHandScore;

			// Consider the total sum of own hands. A lower sum offers more flexibility
			// and less risk of being forced into a bad split.
			const selfSum = selfAlive.reduce((a, b) => a + b, 0);
			if (selfSum > 5) {
				score -= (selfSum - 5) * 20;
			}

			return score;
		}

		function cloneState() {
			return { player: [...hands.player], cpu: [...hands.cpu] };
		}

		function restoreState(state) {
			hands.player = [...state.player];
			hands.cpu = [...state.cpu];
		}

		function applyMove(owner, move) {
			if (move.type === 'attack') {
				const opp = owner === 'cpu' ? 'player' : 'cpu';
				const s = hands[owner][move.src];
				const t = hands[opp][move.dst];
				hands[opp][move.dst] = wrapTo1to5(s + t);
			} else if (move.type === 'split') {
				hands[owner] = [move.left, move.right];
			}
		}

		function enumerateMoves(owner) {
			const opp = owner === 'cpu' ? 'player' : 'cpu';
			const attacks = enumerateAttacks(owner, opp);
			const splits = enumerateSplitsForOwner(owner);
			return { attacks, splits };
		}

		function chooseCpuMoveNormal() {
			const { attacks, splits } = enumerateMoves('cpu');
			const candidates = [...attacks, ...splits];
			if (candidates.length === 0) return null;

			let bestMove = candidates[0] || null;
			let bestValue = -Infinity;
			// A shallow search depth for an easier 'normal' AI, reading 1 move ahead.
			const searchDepth = 1;

			for (const move of candidates) {
				const snapshot = cloneState();
				applyMove('cpu', move);
				// It's now player's turn (minimizing player)
				const value = minimax(searchDepth - 1, false, -Infinity, Infinity);
				restoreState(snapshot);

				if (value > bestValue) {
					bestValue = value;
					bestMove = move;
				}
			}
			return bestMove;
		}

		function chooseCpuMoveStrong() {
			const { attacks, splits } = enumerateMoves('cpu');
			const candidates = [...attacks, ...splits];
			if (candidates.length === 0) return null;

			let bestMove = candidates[0] || null;
			let bestValue = -Infinity;
			// Increased search depth for a stronger AI to find winning moves reliably.
			const searchDepth = 6;

			for (const move of candidates) {
				const snapshot = cloneState();
				applyMove('cpu', move);
				// It's now player's turn (minimizing player)
				const value = minimax(searchDepth - 1, false, -Infinity, Infinity);
				restoreState(snapshot);

				if (value > bestValue) {
					bestValue = value;
					bestMove = move;
				}
			}
			return bestMove;
		}

		function minimax(depth, isMaximizingPlayer, alpha, beta) {
			const term = isTerminalEval();
			if (term !== null) {
				// The evaluation functions (isTerminalEval, heuristicEval) are from the CPU's perspective.
				// We scale by depth to prioritize faster wins.
				return term * (depth + 1);
			}
			if (depth === 0) {
				return heuristicEval();
			}

			const owner = isMaximizingPlayer ? 'cpu' : 'player';
			const { attacks, splits } = enumerateMoves(owner);
			const moves = [...attacks, ...splits];

			if (moves.length === 0) {
				// No moves available, evaluate current board
				return heuristicEval();
			}

			if (isMaximizingPlayer) {
				let maxEval = -Infinity;
				for (const move of moves) {
					const snapshot = cloneState();
					applyMove(owner, move);
					const evaluation = minimax(depth - 1, false, alpha, beta);
					restoreState(snapshot);
					maxEval = Math.max(maxEval, evaluation);
					alpha = Math.max(alpha, evaluation);
					if (beta <= alpha) {
						break; // Beta cut-off
					}
				}
				return maxEval;
			} else { // Minimizing player
				let minEval = Infinity;
				for (const move of moves) {
					const snapshot = cloneState();
					applyMove(owner, move);
					const evaluation = minimax(depth - 1, true, alpha, beta);
					restoreState(snapshot);
					minEval = Math.min(minEval, evaluation);
					beta = Math.min(beta, evaluation);
					if (beta <= alpha) {
						break; // Alpha cut-off
					}
				}
				return minEval;
			}
		}
		function applyCpuMove(move) {
			if (!move) {
				// If AI returned null, try to pick any available move deterministically
				const { attacks, splits } = enumerateMoves('cpu');
				if (attacks.length > 0) {
					// prefer first attack
					move = attacks[0];
				} else if (splits.length > 0) {
					move = splits[0];
				} else {
					// no moves available: fall back to switching turn
					switchTurn();
					updateUI();
					return;
				}
			}

			if (move.type === 'attack') {
				performAttack({ owner: 'cpu', index: move.src }, { owner: 'player', index: move.dst });
				// performAttack handles UI updates and turn switching internally
			} else if (move.type === 'split') {
				hands.cpu = [move.left, move.right];
				if (checkWin()) {
					endGame();
				} else {
					switchTurn();
				}
				updateUI();
			}
		}

		function cpuTurn() {
			let move;
			// In normal mode, act strong for the first 10 turns.
			if (CPU_MODE === 'strong' || (CPU_MODE === 'normal' && turnCount < 10)) {
				move = chooseCpuMoveStrong();
			} else {
				move = chooseCpuMoveNormal();
			}
			applyCpuMove(move);
		}

		// --- Event Listeners ---
		gameContainer.addEventListener('click', handleHandClick);
		// split modal elements
		const splitModalBackdrop = document.getElementById('split-modal-backdrop');
		const splitOptionsContainer = document.getElementById('split-options');
		const splitCancel = document.getElementById('split-cancel');

		splitCancel.addEventListener('click', () => {
			splitModalBackdrop.classList.add('hidden');
		});
		restartButton.addEventListener('click', initializeGame);

		// Game-over CPU mode selector: ensure selection is visible and mode actually changes
		const gameOverCpuBtns = document.querySelectorAll('.cpu-mode-btn-game-over');
		gameOverCpuBtns.forEach(btn => {
			btn.addEventListener('click', () => {
				CPU_MODE = btn.dataset.mode;
				// update visual state
				document.querySelectorAll('.cpu-mode-btn-game-over').forEach(b => b.classList.remove('bg-blue-600', 'bg-gray-700'));
				// reapply background class matching the selected mode
				if (CPU_MODE === 'strong') {
					document.querySelector('.cpu-mode-btn-game-over[data-mode="strong"]').classList.add('bg-blue-600');
					document.querySelector('.cpu-mode-btn-game-over[data-mode="normal"]').classList.add('bg-gray-700');
				} else {
					document.querySelector('.cpu-mode-btn-game-over[data-mode="normal"]').classList.add('bg-blue-600');
					document.querySelector('.cpu-mode-btn-game-over[data-mode="strong"]').classList.add('bg-gray-700');
				}
				// reflect immediately in UI (e.g., cpuModeDisplay)
				updateUI();
			});
		});

		// Start screen events
		startButton.addEventListener('click', () => {
			startScreen.classList.add('hidden');
			gameContainer.classList.remove('hidden');
			initializeGame();
		});

		document.querySelectorAll('.cpu-mode-btn-start').forEach(btn => {
			btn.addEventListener('click', () => {
				CPU_MODE = btn.dataset.mode;
				syncCpuModeButtons();
				updateUI();
			});
		});

		// Ensure game-over buttons also update the CPU mode (syncCpuModeButtons added earlier)
		document.querySelectorAll('.cpu-mode-btn-game-over').forEach(btn => {
			btn.addEventListener('click', () => {
				CPU_MODE = btn.dataset.mode;
				syncCpuModeButtons();
				updateUI();
			});
		});

		// Helper: open split modal for the sum of both player hands
		function openSplitModalSum() {
			const active = [0, 1].filter(i => hands.player[i] !== 5 && hands.player[i] !== 0);
			const sum = active.reduce((s, i) => s + hands.player[i], 0);
			if (sum < 2 || gameState !== 'playing' || turn !== 'player') return;
			splitOptionsContainer.innerHTML = '';
			// Header with current distribution and note about excluded 5s
			const header = document.createElement('div');
			header.className = 'mb-2';
			if (active.length === 2) {
				header.textContent = `現在: 左 ${hands.player[0]} / 右 ${hands.player[1]} → 合計 ${sum}`;
			} else {
				const deadIndex = active.length === 0 ? '両方' : (active[0] === 0 ? '右' : '左');
				header.textContent = `現在: 左 ${hands.player[0]} / 右 ${hands.player[1]} → 合計 ${sum} （${deadIndex} が 0/5 のため除外）`;
			}
			splitOptionsContainer.appendChild(header);
			if (active.length === 2) {
				const currentLeft = hands.player[0];
				const currentRight = hands.player[1];
				// Normalize 5 (dead) to 0 for comparison so that distributions that
				// are numerically identical after treating dead hands as 0 are excluded.
				const normLeft = currentLeft === 5 ? 0 : currentLeft;
				const normRight = currentRight === 5 ? 0 : currentRight;
				for (let a = 0; a <= sum; a++) {
					const b = sum - a;
					// only allow values within 0..5
					if (a > 5 || b > 5) continue;

					// Rule: Do not allow splitting to the same numeric distribution (including swapped)
					// Compare with normalized values so that e.g. 5 is treated as 0.
					if ((a === normLeft && b === normRight) || (a === normRight && b === normLeft)) {
						continue;
					}

					const optionEl = document.createElement('div');
					optionEl.className = 'split-option';
					const label = document.createElement('div');
					label.textContent = `左 ${a}  —  右 ${b}`;
					const applyBtn = document.createElement('button');
					applyBtn.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg';
					applyBtn.textContent = '選択';
					applyBtn.onclick = () => {
						applySplitDistribution(a, b);
						splitModalBackdrop.classList.add('hidden');
					};
					optionEl.appendChild(label);
					optionEl.appendChild(applyBtn);
					splitOptionsContainer.appendChild(optionEl);
				}
			} else if (active.length === 1) {
				// One hand is 0 or 5 (treated as 0). Allow distributing the total among both hands
				const deadIndex = (active[0] === 0) ? 1 : 0; // index of the dead hand
				const note = document.createElement('div');
				note.className = 'mb-2 text-sm text-gray-300';
				note.textContent = `注: 手が 0/5 の方は一時的に 0 として扱い、左右へ配分できます（${deadIndex === 0 ? '左' : '右'} が 0/5）。`;
				splitOptionsContainer.appendChild(note);

				const currentLeft = hands.player[0];
				const currentRight = hands.player[1];
				const normLeft = currentLeft === 5 ? 0 : currentLeft;
				const normRight = currentRight === 5 ? 0 : currentRight;

				for (let a = 0; a <= sum; a++) {
					const b = sum - a;
					if (a > 5 || b > 5) continue;

					// Rule: Do not allow splitting to the same numeric distribution (including swapped)
					if ((a === normLeft && b === normRight) || (a === normRight && b === normLeft)) {
						continue;
					}

					const optionEl = document.createElement('div');
					optionEl.className = 'split-option';
					const label = document.createElement('div');
					label.textContent = `左 ${a}  —  右 ${b}`;
					const applyBtn = document.createElement('button');
					applyBtn.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg';
					applyBtn.textContent = '選択';
					applyBtn.onclick = () => {
						applySplitDistribution(a, b);
						splitModalBackdrop.classList.add('hidden');
					};
					optionEl.appendChild(label);
					optionEl.appendChild(applyBtn);
					splitOptionsContainer.appendChild(optionEl);
				}
			}
			splitModalBackdrop.classList.remove('hidden');
		}

		function applySplitDistribution(leftValue, rightValue) {
			// Assign distribution to both hands (treat 5 as replaceable for distribution)
			hands.player = [leftValue, rightValue];
			// After applying split, proceed to CPU turn
			switchTurn();
			updateUI();
		}

		function applySplitToSingle(index, value) {
			// Only set the active hand; leave 5-handed slot unchanged
			if (hands.player[index] === 5) return;
			hands.player[index] = value;
			switchTurn();
			updateUI();
		}

		function initializeGame() {
			hands = { player: [1, 1], cpu: [1, 1] };
			turnCount = 0; // Reset turn counter
			selectedHand = null;
			gameState = 'playing';
			gameOverScreen.classList.add('hidden');

			// Randomly determine the first turn
			turn = Math.random() < 0.5 ? 'player' : 'cpu';

			// If CPU starts, it needs to think
			if (turn === 'cpu') {
				gameState = 'cpu_thinking';
				updateUI(); // Update UI to show CPU is thinking
				setTimeout(cpuTurn, 500); // Start CPU turn after a short delay
			} else {
				// gameState remains 'playing'
				updateUI(); // Update UI for player's turn
			}
		}


		// --- Initial Render ---
		// Ensure CPU mode buttons reflect current mode on initial load
		syncCpuModeButtons();

		// Game starts when start button is clicked
	</script>
</body>

</html>